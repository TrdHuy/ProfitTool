<!DOCTYPE html>
<html lang="vi">

<head>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <meta charset="UTF-8">
    <title>Param Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <style>
        body {
            font-family: 'Inter', 'Roboto', sans-serif;
            font-size: 14px;
            color: #333;
            padding: 20px;
            margin: auto;
        }

        h2,
        h3 {
            text-align: center;
        }

        /* #region list-item*/
        /* Param v√† Formula item chung */
        .param-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-radius: 4px;
            margin: 3px 0;
            background: var(--list-item-bg, #fafafa);
            /* default m√†u */
            transition: background 0.2s, transform 0.1s;
        }

        .param-item:hover {
            background: #f5faff;
        }

        .param-item:active {
            background: #dbe9ff;
            transform: scale(0.98);
        }

        .group-header {
            font-weight: bold;
            cursor: pointer;
            background: #eee;
            padding: 4px;
            border-radius: 4px;
        }

        .group-children {
            margin-left: 20px;
        }

        /* #endregion */
        .block {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .scroll-box {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 5px;
            margin-top: 10px;
            border-radius: 4px;
            background: #fafafa;
        }

        label {
            display: block;
            margin-top: 5px;
        }

        input {
            padding: 5px;
            margin: 3px 0;
        }

        button {
            margin-top: 10px;
            padding: 6px 12px;
        }

        .formula-result {
            font-weight: bold;
            color: darkblue;
        }

        .group-header {
            background: #eee;
            padding: 5px;
            margin-top: 5px;
            border-radius: 4px;
            cursor: pointer;
        }

        .group-header:hover {
            background: #ddd;
        }


        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menubar {
            display: flex;
            gap: 10px;
            background: #f0f0f0;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 15px;
            align-items: center;
        }

        /* Style n√∫t */
        .menubar button,
        .menubar .menu-btn {
            margin: 2px;
            background: #ffffff;
            border: 1px solid #bbb;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s, box-shadow 0.2s;
        }

        /* Hover effect */
        .menubar button:hover,
        .menubar .menu-btn:hover {
            background: #e6f0ff;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

        .context-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-width: 120px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
        }

        .context-menu-item {
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        /* ·∫®n input file th·∫≠t, ch·ªâ show label gi·∫£ n√∫t */
        #importFile {
            display: none;
        }

        .formula-block {
            flex: 1;
            /* t·ª± chi·∫øm ph·∫ßn c√≤n l·∫°i */
        }

        .mouse-effect-no-select {
            user-select: none;
            /* chu·∫©n */
            -webkit-user-select: none;
            /* Safari/Chrome */
            -ms-user-select: none;
            /* IE/Edge c≈© */
        }

        /* Khi xoay ngang (chi·ªÅu r·ªông > chi·ªÅu cao) th√¨ ƒë·ªïi layout ngang */
        /* Mobile th∆∞·ªùng c√≥ pointer: coarse (ng√≥n tay), c√≤n PC l√† fine (chu·ªôt) */
        @media (orientation: landscape) {
            .container {
                display: flex;
                flex-direction: row;
                height: 100%;
                gap: 0px;
            }

            .divider {
                width: 30px;
                cursor: col-resize;
                background: #ddd;
            }

            .divider:hover {
                background: #aaa;
            }

            .param-block {
                min-width: 30%;
                max-width: 60%;
            }
        }

        @media (orientation: landscape) and (pointer: coarse) {
            .container {
                display: flex;
                flex-direction: row;
                height: 100%;
                gap: 0px;
            }

            .divider {
                width: 10px;
                cursor: col-resize;
                background: #ddd;
            }

            .divider:hover {
                background: #aaa;
            }

            .param-block {
                min-width: 30%;
                max-width: 60%;
            }
        }
    </style>
</head>

<body>
    <h2>Param Editor</h2>
    <div class="menubar">
        <button onclick="exportData()">üíæ Export</button>

        <label for="importFile" class="menu-btn">üìÇ Import</label>
        <input type="file" id="importFile" accept=".json" onchange="importData(this)">
        <button onclick="clearWorkspace()">üßπ Clear</button>
        <button onclick="toggleFullscreen()">üî≥ Toggle Fullscreen</button>

    </div>
    <div class="container" id="mainContainer">
        <!-- Th√™m tham s·ªë -->
        <div class="block param-block" id="paramContainer">
            <h3 onclick="toggleBlock('paramBlock')" style="cursor:pointer;">
                ‚ûï Th√™m tham s·ªë
            </h3>

            <div id="paramBlock">
                <label>T√™n param:</label>
                <auto-scroll-input type="text" id="paramName" placeholder="V√≠ d·ª•: A"></auto-scroll-input>
                <label>M√¥ t·∫£:</label>
                <auto-scroll-input type="text" id="paramDesc" placeholder="V√≠ d·ª•: s·ªë l∆∞·ª£ng m√°y"></auto-scroll-input>
                <label>Gi√° tr·ªã:</label>
                <auto-scroll-input type="number" id="paramValue" placeholder="V√≠ d·ª•: 10"></auto-scroll-input>
                <label>Group:</label>
                <auto-scroll-input type="text" id="paramGroup" placeholder="V√≠ d·ª•: Nh√¢n s·ª±"></auto-scroll-input>

                <label>M√†u n·ªÅn:</label>
                <input type="color" id="paramColor" value="#f0f0f0">

                <label>Format:</label>
                <select id="paramFormat"></select>

                <button onclick="addParam()" id="addParamButton">Th√™m tham s·ªë</button>
            </div>
            <param-list id="paramsView" onitemclick="handleItemClick" onitemcontextmenu="handleContextMenu('param')"
                ongrouptoggle="handleGroupToggle">
                <template>
                    <div class="param-item">
                        <div style="display: block;">
                            <span>{{name}}</span> =
                            <formatted-input value="{{value}}" format="{{format}}"></formatted-input>
                            <div style="font-size:12px; color:#666;">{{desc}}</div>
                        </div>
                    </div>

                </template>
            </param-list>
        </div>

        <div class="divider" id="divider"></div>
        <!-- Th√™m c√¥ng th·ª©c -->
        <div class="block formula-block" id="formulaContainer">
            <h3>Th√™m c√¥ng th·ª©c</h3>
            <label>T√™n c√¥ng th·ª©c:</label>
            <auto-scroll-input type="text" id="formulaName" placeholder="V√≠ d·ª•: Doanh thu"></auto-scroll-input>
            <label>M√¥ t·∫£:</label>
            <auto-scroll-input type="text" id="formulaDesc"
                placeholder="V√≠ d·ª•: doanh thu h√†ng th√°ng"></auto-scroll-input>
            <label>Group:</label>
            <auto-scroll-input type="text" id="formulaGroup" placeholder="V√≠ d·ª•: doanh thu"></auto-scroll-input>
            <label>C√¥ng th·ª©c:</label>
            <auto-scroll-input type="text" id="formulaInput" placeholder="V√≠ d·ª•: A + B * 2"></auto-scroll-input>
            <button onclick="addFormula()" id="addFormulaButton">Th√™m c√¥ng th·ª©c</button>
            <param-list id="formulasView" onitemclick="handleItemClick" onitemcontextmenu="handleContextMenu('formula')"
                ongrouptoggle="handleGroupToggle">
                <template>
                    <div class="param-item">
                        <div style="display: block;">
                            <span>{{name}}</span>:
                            <span>{{display}}</span> =
                            <formatted-input value="{{result}}" readonly></formatted-input>
                            <div style="font-size:12px; color:#666;">{{desc}}</div>
                        </div>
                    </div>
                </template>
            </param-list>
        </div>


    </div>
    <div id="contextMenu" class="context-menu">
    </div>
    <script des="definition">
        const isMobile = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent);
    </script>
    <script des="utils">
        class ObservableListItem {
            constructor(data = {}, children = null) {
                // Copy to√†n b·ªô field t·ª´ dict v√†o object
                Object.assign(this, data);

                // T·∫°o danh s√°ch con n·∫øu c√≥
                if (children instanceof ObservableList) {
                    this.children = children;
                } else if (Array.isArray(children)) {
                    this.children = new ObservableList(children);
                } else if (Array.isArray(data.children)) {
                    this.children = new ObservableList(data.children);
                } else if (data.children instanceof ObservableList) {
                    this.children = data.children;
                } else {
                    this.children = null;
                }

                // ‚úÖ G√°n parent cho children n·∫øu c√≥
                if (this.children) {
                    this.children._parent = this;
                }

                const self = this;
                const proxy = new Proxy(this, {
                    set(target, prop, value) {
                        const oldValue = target[prop];
                        const changed = oldValue !== value;
                        if (
                            changed &&
                            prop !== "parent" &&
                            prop !== "children" &&
                            typeof prop === "string"
                        ) {

                            // N·∫øu item c√≥ listener ri√™ng
                            if (self._beforeValueChangedlisteners && self._beforeValueChangedlisteners.size > 0) {
                                self._beforeValueChangedlisteners.forEach(cb =>
                                    value = cb({ field: prop, oldValue, newValue: value, item: proxy }) || value
                                );
                            }
                        }
                        // g√°n gi√° tr·ªã
                        target[prop] = value;

                        // n·∫øu gi√° tr·ªã thay ƒë·ªïi v√† kh√¥ng ph·∫£i internal field ‚Üí ph√°t s·ª± ki·ªán
                        if (
                            changed &&
                            prop !== "parent" &&
                            prop !== "children" &&
                            typeof prop === "string"
                        ) {

                            // N·∫øu item c√≥ listener ri√™ng
                            if (self._valueChangedListeners && self._valueChangedListeners.size > 0) {
                                self._valueChangedListeners.forEach(cb =>
                                    cb({ field: prop, oldValue, newValue: value, item: proxy })
                                );
                            }
                        }

                        return true;
                    },
                    get(target, prop) {
                        return target[prop];
                    },
                });
                // l∆∞u set listener ri√™ng cho item n·∫øu c·∫ßn
                proxy._valueChangedListeners = new Set();
                proxy._beforeValueChangedlisteners = new Set();
                proxy.registerListener = cb => proxy._valueChangedListeners.add(cb);
                proxy.unregisterListener = cb => proxy._valueChangedListeners.delete(cb);
                proxy.registerBeforeValueChangedListener = cb => proxy._beforeValueChangedlisteners.add(cb);
                proxy.unregisterBeforeValueChangedListener = cb => proxy._beforeValueChangedlisteners.delete(cb);
                proxy.toPlainObject = () => ObservableListItem.toPlain(proxy);


                return proxy;
            }
            static fromPlain(data) {
                if (!data || typeof data !== "object") return null;

                const { children, ...rest } = data;
                const childItems = Array.isArray(children)
                    ? children.map(ObservableListItem.fromPlain).filter(Boolean)
                    : undefined;

                const item = new ObservableListItem(rest, childItems);
                return item;
            }
            static toPlain(item) {
                if (!item || typeof item !== "object") return {};

                const plain = {};

                Object.keys(item).forEach(key => {
                    if (key === "parent" || key === "children") return;
                    if (key.startsWith("_")) return;

                    const value = item[key];
                    if (typeof value === "function") return;
                    if (value instanceof Set) return;

                    plain[key] = value;
                });

                const { children } = item;
                if (children && typeof children.toPlainArray === "function") {
                    plain.children = children.toPlainArray();
                } else if (Array.isArray(children)) {
                    plain.children = children.map(ObservableListItem.toPlain);
                }

                return plain;
            }
        }

        class ObservableList {
            static findGroupRecursive(list, name) {
                for (const it of list.items) {
                    if (it.name === name && it.children instanceof ObservableList) return it;
                    if (it.children) {
                        const found = ObservableList.findGroupRecursive(it.children, name);
                        if (found) return found;
                    }
                }
                return null;
            }

            constructor(items = [], parent = null) {
                this._items = items;
                this._listeners = new Set();      // collection listeners
                this._itemListeners = new Set();  // item change listeners
                this._parent = parent; // list cha (c√≥ th·ªÉ l√† list g·ªëc ho·∫∑c group con)

                const proxy = new Proxy(this, {
                    get: (target, prop) => {
                        if (prop === "registerListener") return cb => target._listeners.add(cb);
                        if (prop === "unregisterListener") return cb => target._listeners.delete(cb);

                        if (prop === "registerItemListener") return cb => target._itemListeners.add(cb);
                        if (prop === "unregisterItemListener") return cb => target._itemListeners.delete(cb);

                        if (prop === "addNewGroup") {
                            return (groupName) => {
                                if (!groupName) {
                                    return;
                                }
                                let group = ObservableList.findGroupRecursive(proxy, groupName);
                                if (!group) {
                                    // N·∫øu ch∆∞a c√≥ group ‚Üí t·∫°o m·ªõi ·ªü root
                                    group = new ObservableListItem({
                                        name: groupName,
                                        expanded: true,
                                        children: new ObservableList([], proxy)
                                    });
                                    proxy.push(group);
                                }

                                if (!group.children) {
                                    group.children = new ObservableList([], proxy);
                                }
                                return group;
                            };
                        }
                        if (prop === "addToGroup") {
                            return (groupName, item) => {
                                if (!(item instanceof ObservableListItem)) {
                                    throw new Error("addToGroup() expects an ObservableListItem instance.");
                                }

                                // N·∫øu kh√¥ng nh·∫≠p group name ‚Üí th√™m th·∫≥ng v√†o root
                                if (!groupName) {
                                    proxy.push(item);
                                    return;
                                }
                                let group = ObservableList.findGroupRecursive(proxy, groupName);
                                if (!group) {
                                    // N·∫øu ch∆∞a c√≥ group ‚Üí t·∫°o m·ªõi ·ªü root
                                    group = new ObservableListItem({
                                        name: groupName,
                                        expanded: true,
                                        children: new ObservableList([], proxy)
                                    });
                                    proxy.push(group);
                                }

                                // Th√™m item v√†o trong group
                                if (!group.children) {
                                    group.children = new ObservableList([], proxy);
                                }
                                item.groupName = groupName;
                                group.children.push(item);
                            };
                        }

                        if (prop === "push") {
                            return (...args) => {
                                args.forEach(it => {
                                    if (!(it instanceof ObservableListItem)) {
                                        throw new Error("push() expects only ObservableListItem instances.");
                                    }
                                    it.parent = proxy;
                                });
                                const startIndex = target._items.length;
                                const result = target._items.push(...args);
                                args.forEach((item, i) =>
                                    target._notifyCollection({ action: "add", index: startIndex + i, item })
                                );
                                return result;
                            };
                        }

                        if (prop === "set") {
                            return (i, val) => {
                                if (!(val instanceof ObservableListItem)) {
                                    throw new Error("set() expects an ObservableListItem instance.");
                                }
                                val.parent = proxy;
                                const oldItem = target._items[i];
                                target._items[i] = val;
                                target._notifyCollection({ action: "set", oldItem, newItem: val });
                            };
                        }

                        if (prop === "remove") {
                            return (item) => {
                                const index = target._items.indexOf(item);
                                if (index === -1) return false; // kh√¥ng t√¨m th·∫•y

                                // X√≥a item kh·ªèi danh s√°ch
                                const removed = target._items.splice(index, 1);
                                removed.forEach(it => (it.parent = null));

                                // G·ª≠i s·ª± ki·ªán th√¥ng b√°o
                                target._notifyCollection({
                                    action: "remove",
                                    index,
                                    items: removed
                                });

                                return true;
                            };
                        }

                        if (prop === "splice") {
                            return (start, deleteCount, ...itemsToAdd) => {
                                itemsToAdd.forEach(it => {
                                    if (!(it instanceof ObservableListItem)) {
                                        throw new Error("splice() expects only ObservableListItem instances.");
                                    }
                                    it.parent = proxy;
                                });

                                const removed = target._items.splice(start, deleteCount, ...itemsToAdd);
                                removed.forEach(it => (it.parent = null));

                                // G·ª≠i s·ª± ki·ªán thay ƒë·ªïi
                                if (removed.length > 0 && itemsToAdd.length === 0) {
                                    target._notifyCollection({ action: "remove", index: start, items: removed });
                                } else if (removed.length === 0 && itemsToAdd.length > 0) {
                                    itemsToAdd.forEach((it, i) =>
                                        target._notifyCollection({ action: "add", index: start + i, item: it })
                                    );
                                } else {
                                    target._notifyCollection({
                                        action: "splice",
                                        index: start,
                                        removed,
                                        added: itemsToAdd
                                    });
                                }

                                return removed;
                            };
                        }


                        if (prop === "toPlainArray") {
                            return () => target._items.map(ObservableListItem.toPlain);
                        }
                        if (prop === "parent") return target._parent;
                        if (prop === "items") return target._items;
                        if (prop === "notifyCollection") return e => target._notify(e);
                        return target._items[prop];
                    }
                });

                // ‚úÖ set parent ƒë√∫ng proxy cho t·∫•t c·∫£ item ban ƒë·∫ßu
                this._items.forEach(it => {
                    if (!(it instanceof ObservableListItem)) {
                        console.error("Invalid item:", it);
                        throw new Error("All items in ObservableList must be instances of ObservableListItem.");
                    }
                    it.parent = proxy;
                });

                return proxy;
            }
            _notifyCollection(e) { this._listeners.forEach(cb => cb(e)); }
            _notifyItem(e) { this._itemListeners.forEach(cb => cb(e)); }
            static serialize(list) {
                if (!(list instanceof ObservableList)) return [];
                return list.toPlainArray();
            }
            static loadFromPlain(list, dataArray = []) {
                if (!(list instanceof ObservableList)) return;

                list.splice(0, list.items.length);
                if (!Array.isArray(dataArray)) return;

                dataArray.forEach(data => {
                    const item = ObservableListItem.fromPlain(data);
                    if (item) {
                        list.push(item);
                    }
                });
            }
        }

        class ObservableIndexer {
            constructor(observableList, keyField = "name", recursive = true) {
                this._keyField = keyField;
                this._index = new Map();          // key ‚Üí item
                this._rootList = observableList;  // root list ƒëang theo d√µi
                this._recursive = recursive;

                // ƒêƒÉng k√Ω listener
                observableList.registerListener(e => this._onCollectionChanged(e));

                // Kh·ªüi t·∫°o index ban ƒë·∫ßu
                this._buildIndex(observableList);
            }

            _buildIndex(list) {
                for (const item of list.items) {
                    this._tryAdd(item);
                    if (this._recursive && item.children instanceof ObservableList) {
                        this._buildIndex(item.children);
                    }
                }
            }

            _onCollectionChanged(e) {
                if (e.action === "add") {
                    this._tryAdd(e.item);
                } else if (e.action === "remove") {
                    e.items.forEach(it => this._remove(it));
                } else if (e.action === "splice") {
                    e.removed.forEach(it => this._remove(it));
                    e.added.forEach(it => this._tryAdd(it));
                } else if (e.action === "set") {
                    this._remove(e.oldItem);
                    this._tryAdd(e.newItem);
                }

                // N·∫øu c√≥ children th√¨ c≈©ng c·∫ßn theo d√µi recursive
                if (this._recursive) {
                    const items = e.items || [e.item].filter(Boolean);
                    items.forEach(it => {
                        if (it.children instanceof ObservableList) {
                            it.children.registerListener(ev => this._onCollectionChanged(ev));
                            this._buildIndex(it.children);
                        }
                    });
                }
            }

            _tryAdd(item) {
                const key = item[this._keyField];
                if (key == null) return;
                this._index.set(key, item);

                // Theo d√µi rename ƒë·ªông (n·∫øu c√≥ setter trigger)
                if (Object.getOwnPropertyDescriptor(Object.getPrototypeOf(item), this._keyField) == null) {
                    // n·∫øu ch∆∞a c√≥ getter/setter th√¨ th√™m dynamic watcher
                    let val = key;
                    Object.defineProperty(item, this._keyField, {
                        get() { return val; },
                        set: newVal => {
                            const oldVal = val;
                            val = newVal;
                            this._onItemKeyChanged(item, oldVal, newVal);
                        },
                        configurable: true,
                        enumerable: true,
                    });
                }
            }

            _remove(item) {
                const key = item[this._keyField];
                if (key != null && this._index.get(key) === item) {
                    this._index.delete(key);
                }
                if (this._recursive && item.children instanceof ObservableList) {
                    for (const child of item.children.items) {
                        this._remove(child);
                    }
                }
            }

            _onItemKeyChanged(item, oldKey, newKey) {
                if (this._index.get(oldKey) === item) this._index.delete(oldKey);
                this._index.set(newKey, item);
            }

            // API public
            get(key) { return this._index.get(key) || null; }
            has(key) { return this._index.has(key); }
            delete(key) { return this._index.delete(key); }
            keys() { return Array.from(this._index.keys()); }
            values() { return Array.from(this._index.values()); }
            entries() { return Array.from(this._index.entries()); }
        }

    </script>
    <script des="views">

        class ParamListView extends HTMLElement {
            static TAGS = {
                item_template: "template",
                param_list: "param-list"
            };
            static CLASSES = {
                item: "param-item",
                groupBlock: "group-block",
                groupHeader: "group-header",
                groupChildren: "group-children",
            };
            constructor() {
                super();
                this._data = null;
                this._itemElems = new Map();
                this._onCollectionChanged = this.onCollectionChanged.bind(this);
            }


            set data(list) {
                if (this._data) this._data.unregisterListener(this._onCollectionChanged);
                this._data = list;
                if (list) list.registerListener(this._onCollectionChanged);
                this.renderAll();
            }
            get data() { return this._data; }

            get rootView() {
                return this._rootView || this; // fallback v·ªÅ ch√≠nh n√≥ n·∫øu ch∆∞a c√≥
            }
            set rootView(v) {
                this._rootView = v;
            }
            get itemElems() {
                return this.rootView._itemElems
            }

            renderAll() {
                const C = ParamListView.CLASSES;
                const T = ParamListView.TAGS;

                this.querySelectorAll(`.${C.item}, .${C.groupBlock}`).forEach(el => el.remove());
                if (this === this.rootView) {
                    this._itemElems.clear();
                }

                if (!this._data) return;
                const template = this.querySelector(T.item_template);
                if (!template) return;

                this._data.items.forEach(p => {
                    const elem = this._createItemElement(p);
                    this.appendChild(elem);
                    this.itemElems.set(p, elem);
                });
            }

            onCollectionChanged(e) {
                console.log("onCollectionChanged:", { e });
                switch (e.action) {
                    case "add":
                        this._handleAdd(e);
                        break;

                    case "remove":
                        this._handleRemove(e);
                        break;

                    case "set":
                        this._handleSet(e);
                        break;

                    case "splice":
                        this._handleSplice(e);
                        break;
                }
            }

            _isAncestor(ancestor, node) {
                if (!ancestor || !node || ancestor === node) return false;

                let current = node.parent;
                while (current) {
                    if (current === ancestor) return true;
                    // N·∫øu current l√† ObservableList th√¨ nh·∫£y ti·∫øp l√™n cha c·ªßa list ƒë√≥ (n·∫øu c√≥)
                    if (current.parent) {
                        current = current.parent;
                    } else {
                        // current l√† item nh∆∞ng kh√¥ng c√≥ parent list
                        break;
                    }
                }
                return false;
            }


            _getItemElements() {
                const C = ParamListView.CLASSES;
                return Array.from(this.children).filter(
                    el => el.classList.contains(C.item) || el.classList.contains(C.groupBlock)
                );
            }

            _handleAdd(e) {
                const elem = this._createItemElement(e.item);
                const itemElems = this._getItemElements();
                const refElem = itemElems[e.index];
                if (refElem) this.insertBefore(elem, refElem);
                else this.appendChild(elem);
                this.itemElems.set(e.item, elem);
            }

            _handleRemove(e) {
                // e.items c√≥ th·ªÉ l√† m·∫£ng item b·ªã xo√°
                const removedItems = e.items || (e.item ? [e.item] : []);
                removedItems.forEach(item => {
                    const elem = this.itemElems.get(item);
                    if (elem) {
                        elem.remove();
                        this.itemElems.delete(item);
                    }
                });
            }

            _handleSet(e) {
                const oldElem = this.itemElems.get(e.oldItem);
                if (oldElem) {
                    const newElem = this._createItemElement(e.newItem);
                    oldElem.replaceWith(newElem);
                    this.itemElems.delete(e.oldItem);
                    this.itemElems.set(e.newItem, newElem);
                }
            }

            /**
             * e = { action: "splice", index, removed, added }
             */
            _handleSplice(e) {
                // 1Ô∏è‚É£ X√≥a ph·∫ßn t·ª≠ c≈© (n·∫øu c√≥)
                if (Array.isArray(e.removed)) {
                    e.removed.forEach(item => {
                        const el = this.itemElems.get(item);
                        if (el) {
                            el.remove();
                            this.itemElems.delete(item);
                        }
                    });
                }

                // 2Ô∏è‚É£ Th√™m ph·∫ßn t·ª≠ m·ªõi (n·∫øu c√≥)
                if (Array.isArray(e.added)) {
                    e.added.forEach((item, i) => {
                        const elem = this._createItemElement(item);

                        // x√°c ƒë·ªãnh ph·∫ßn t·ª≠ tham chi·∫øu
                        const nextItem = this._data.items[e.index + i + 1];
                        const refElem = nextItem ? this.itemElems.get(nextItem) : null;

                        if (refElem) this.insertBefore(elem, refElem);
                        else this.appendChild(elem);

                        this.itemElems.set(item, elem);
                    });
                }
            }

            _createItemElement(itemData) {
                const C = ParamListView.CLASSES;
                const T = ParamListView.TAGS;
                // --- group ---
                if (itemData.children) {
                    const groupBlock = document.createElement("div");
                    groupBlock.className = C.groupBlock;

                    const header = document.createElement("div");
                    header.className = C.groupHeader;
                    header.textContent =
                        (itemData.expanded ? "‚ñº " : "‚ñ∂ ") + itemData.name + " (Group)";
                    groupBlock.appendChild(header);

                    const childrenContainer = document.createElement("div");
                    childrenContainer.className = C.groupChildren;
                    childrenContainer.style.display = itemData.expanded ? "block" : "none";

                    const childList = document.createElement(T.param_list);
                    childList.innerHTML = this.querySelector(T.item_template).outerHTML;
                    childList.rootView = this.rootView ?? this;
                    childList.data = itemData.children;
                    childrenContainer.appendChild(childList);
                    groupBlock.appendChild(childrenContainer);

                    // toggle expand/collapse
                    header.addEventListener("click", () => {
                        itemData.expanded = !itemData.expanded;
                        childrenContainer.style.display = itemData.expanded ? "block" : "none";
                        header.textContent =
                            (itemData.expanded ? "‚ñº " : "‚ñ∂ ") + itemData.name + " (Group)";
                        this._emitEvent("grouptoggle", { group: itemData, expanded: itemData.expanded });
                    });

                    // drag/drop
                    this._attachDragDrop(header, itemData);
                    this._attachItemEvents(header, itemData);
                    return groupBlock;
                }

                // --- item th∆∞·ªùng ---
                const template = this.querySelector(T.item_template);
                const fragment = template.content.cloneNode(true);

                this._bindFragmentToItem(fragment, itemData);

                const container = document.createElement("div");
                container.appendChild(fragment);
                const elem = container.firstElementChild;
                elem.classList.add(C.item);

                this._attachDragDrop(elem, itemData);
                this._attachItemEvents(elem, itemData);
                return elem;
            }

            _attachDragDrop(elem, itemData) {
                const root = this.rootView ?? this;
                elem.draggable = true;

                function isAbleToDrop(listView, fromNode, toNode) {
                    return listView._isAncestor(fromNode, toNode)
                }
                elem.addEventListener("dragstart", e => {
                    e.stopPropagation();
                    e.dataTransfer.effectAllowed = "move";
                    root._draggingItem = itemData;
                    elem.classList.add("dragging");
                    console.log("dragstart:", itemData.name);
                });

                elem.addEventListener("dragend", e => {
                    elem.classList.remove("dragging");
                    root._draggingItem = null;
                });

                elem.addEventListener("dragover", e => {
                    e.preventDefault();
                    const fromItem = root._draggingItem;
                    const toItem = itemData;
                    if (this._isAncestor(fromItem, toItem)) {
                        return;
                    }
                    elem.style.borderTop = "2px solid blue";
                });

                elem.addEventListener("dragleave", e => {
                    elem.style.borderTop = "";
                });

                elem.addEventListener("drop", e => {
                    e.preventDefault();
                    elem.style.borderTop = "";

                    const fromItem = root._draggingItem;
                    const toItem = itemData;
                    console.log("drop:", { toItem, fromItem });

                    if (!fromItem || fromItem === toItem) return;
                    if (this._isAncestor(fromItem, toItem)) {
                        return;
                    }
                    const fromList = fromItem.parent;
                    const toList = toItem.parent;
                    if (!fromList || !toList) return;

                    const fromIndex = fromList.items.indexOf(fromItem);
                    const toIndex = toList.items.indexOf(toItem);
                    if (fromIndex === -1 || toIndex === -1) return;

                    console.log(`drop ${fromItem.name} ‚Üí ${toItem.name}`);

                    const [moved] = fromList.splice(fromIndex, 1);
                    const adjustedIndex =
                        fromList === toList && fromIndex < toIndex ? toIndex - 1 : toIndex;

                    toList.splice(adjustedIndex, 0, moved);
                });
            }

            _bindFragmentToItem(fragment, itemData) {
                const bindings = []; // danh s√°ch li√™n k·∫øt { key, node, type, attrName? }

                // 1Ô∏è‚É£ Text nodes
                const walker = document.createTreeWalker(fragment, NodeFilter.SHOW_TEXT, null, false);
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    const matches = node.textContent.match(/{{\s*([\w]+)\s*}}/g);
                    if (matches) {
                        matches.forEach(m => {
                            const key = m.replace(/[{}]/g, "").trim();
                            if (itemData[key] !== undefined) {
                                // render ban ƒë·∫ßu
                                node.textContent = node.textContent.replace(m, itemData[key]);
                                // l∆∞u l·∫°i binding
                                bindings.push({ key, node, type: "text" });
                            }
                        });
                    }
                }

                // 2Ô∏è‚É£ Attributes
                fragment.querySelectorAll("*").forEach(el => {
                    for (let attr of el.attributes) {
                        const m = attr.value.match(/{{\s*([\w]+)\s*}}/);
                        if (m) {
                            const key = m[1];
                            if (itemData[key] !== undefined) {
                                // render ban ƒë·∫ßu
                                el.setAttribute(attr.name, itemData[key]);

                                // n·∫øu l√† input.value ‚Üí t·∫°o 2 chi·ªÅu
                                if (attr.name === "value" && el.tagName === "INPUT") {
                                    el.value = itemData[key];
                                    el.addEventListener("input", () => {
                                        console.log("el input changed");
                                        itemData[key] = el.value; // view ‚Üí model
                                    });
                                }

                                // l∆∞u l·∫°i binding (ƒë·ªÉ update khi model ƒë·ªïi)
                                bindings.push({ key, node: el, type: "attr", attrName: attr.name });
                            }
                        }
                    }
                });

                // 3Ô∏è‚É£ Khi model thay ƒë·ªïi ‚Üí update view
                if (typeof itemData.registerListener === "function") {
                    itemData.registerListener(e => {
                        const { field, newValue } = e;
                        bindings.forEach(b => {
                            if (b.key === field) {
                                if (b.type === "text") {
                                    b.node.textContent = newValue; // update text node
                                } else if (b.type === "attr") {
                                    b.node.setAttribute(b.attrName, newValue);
                                    if (b.attrName === "value" && b.node.tagName === "INPUT") {
                                        b.node.value = newValue; // model ‚Üí view
                                    }
                                }
                            }
                        });
                    });
                }

                return bindings;
            }

            // ==================== EVENT BINDING ====================

            _emitEvent(type, detail) {
                // T·∫°o b·∫£n sao detail ƒë·ªÉ c√≥ th·ªÉ th√™m extraParam sau
                let eventDetail = { ...detail };

                const event = new CustomEvent(type, {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    detail: eventDetail
                });

                this.dispatchEvent(event);

                const attrName = "on" + type.toLowerCase();
                const inlineHandler = this.rootView.getAttribute(attrName);

                if (inlineHandler) {
                    const match = inlineHandler.match(/^(\w+)\((.*)\)$/);
                    if (match) {
                        const fnName = match[1];
                        const argsStr = match[2].trim();

                        if (window[fnName]) {
                            let extraParam = null;

                            if (argsStr) {
                                try {
                                    extraParam = new Function(`return [${argsStr}]`)();
                                } catch (e) {
                                    console.warn("Failed to parse inline params:", e);
                                }
                            }

                            // G·∫Øn extraParam v√†o event.detail m√† KH√îNG ghi ƒë√® event.detail
                            event.detail.extraParam = extraParam;

                            window[fnName](event);
                        }
                    } else {
                        if (window[inlineHandler]) {
                            window[inlineHandler](event);
                        }
                    }
                }
            }

            _attachItemEvents(elem, itemData) {
                elem.addEventListener("click", e => {
                    e.stopPropagation();
                    this._emitEvent("itemclick", { item: itemData, element: elem });
                });

                elem.addEventListener("contextmenu", e => {
                    e.preventDefault();
                    e.stopPropagation();
                    this._emitEvent("itemcontextmenu", {
                        item: itemData,
                        element: elem,
                        x: e.clientX,
                        y: e.clientY
                    });
                });
            }

        }

        class AutoScrollInput extends HTMLElement {
            constructor() {
                super();
                this._input = document.createElement('input');
                this.appendChild(this._input);
            }
            connectedCallback() {
                if (typeof isMobile !== 'undefined' && isMobile) {
                    this._input.addEventListener('focus', () => {
                        setTimeout(() => this._input.scrollIntoView({ behavior: 'smooth', block: 'center' }), 300);
                    });
                }
            }
            get value() { return this._input.value; }
            set value(v) { this._input.value = v; }
        }

        class FormattedInput extends AutoScrollInput {
            static get observedAttributes() {
                return ["value", "format", "min", "max", "step", "spinner", "readonly"];
            }
            constructor() {
                super();
                this._rawValue = '';
                this._updating = false; // ch·ªëng v√≤ng l·∫∑p attribute ‚Üî setter

                // style n·ªôi b·ªô (kh√¥ng d√πng shadow ƒë·ªÉ cho ph√©p CSS var t·ª´ host)
                this._style = document.createElement('style');
                this._style.textContent = `
          input {
            font-size: var(--fi-font-size, 16px);
            padding: var(--fi-padding, 6px 8px);
            width: var(--fi-width, 180px);
            border: 1px solid var(--fi-border-color, #ccc);
            border-radius: var(--fi-radius, 6px);
            background: var(--fi-bg, #fff);
            color: var(--fi-text-color, #222);
            text-align: right;
            box-sizing: border-box;
          }
          input:focus { outline: none; border-color: var(--fi-focus, #66aaff); box-shadow: 0 0 2px var(--fi-focus, #66aaff); }
        `;
                this.appendChild(this._style);

                // input mode ‚Äì m·∫∑c ƒë·ªãnh l√† text ƒë·ªÉ hi·ªÉn th·ªã chu·ªói format; s·∫Ω chuy·ªÉn sang number khi focus
                this._input.type = 'text';
                this._input.inputMode = 'decimal';

                // Hi·ªÉn th·ªã gi√° tr·ªã ƒë√£ format l·∫ßn ƒë·∫ßu n·∫øu c√≥ attribute value
                if (this.hasAttribute('value')) {
                    const num = this._parseToNumber(this.getAttribute('value'));
                    this._rawValue = isNaN(num) ? '' : num;
                    this._render();
                }

                // focus: hi·ªán raw value + b·∫≠t spinner n·∫øu c·∫ßn
                this._input.addEventListener('focus', () => {
                    if (this._isReadonly()) return;
                    this._input.value = this._rawValue ?? '';
                    if (this._shouldShowSpinner()) {
                        this._input.type = 'number';
                        this._applyNumericAttrs();
                    }
                });

                // blur: chuy·ªÉn v·ªÅ text tr∆∞·ªõc r·ªìi format l·∫°i; n·∫øu r·ªóng, gi·ªØ nguy√™n gi√° tr·ªã c≈©
                this._input.addEventListener('blur', () => {
                    const current = this._input.value;
                    this._input.type = 'text';
                    const val = (current === '' || current == null) ? this._rawValue : current;
                    this.value = val; // setter s·∫Ω parse & render
                });

                // change: b·∫Øn s·ª± ki·ªán cho cha bi·∫øt
                this._input.addEventListener('change', () => {
                    if (this._isReadonly()) return;
                    this._emitChanged();
                });

                // keyboard ‚Üë‚Üì: h·ªó tr·ª£ step ngay c·∫£ khi type=text
                this._input.addEventListener('keydown', (e) => {
                    if (this._isReadonly()) { e.preventDefault(); return; }
                    if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && this._isNumericFormat()) {
                        e.preventDefault();
                        const step = this._readNumberAttr('step', 1);
                        const dir = e.key === 'ArrowUp' ? 1 : -1;
                        let next = (parseFloat(this._input.value || this._rawValue) || 0) + dir * step;
                        const min = this._readNumberAttr('min', null);
                        const max = this._readNumberAttr('max', null);
                        if (min !== null) next = Math.max(min, next);
                        if (max !== null) next = Math.min(max, next);
                        this._input.value = String(next);
                    }
                });
            }

            // ===== Formatters =====
            static FORMATTERS = {
                number: {
                    label: "S·ªë nguy√™n",
                    fn: (v) => {
                        const n = parseFloat(v); return isNaN(n) ? '' : n.toLocaleString('vi-VN');
                    }
                },
                currency: {
                    label: "Ti·ªÅn t·ªá (VND)",
                    fn: (v) => {
                        const n = parseFloat(v); return isNaN(n) ? '' : new Intl.NumberFormat('vi-VN').format(n) + ' ‚Ç´';
                    }
                },
                vnd: {
                    label: "Ti·ªÅn t·ªá (VND)",
                    hidden: true,
                    fn: (v) => {
                        const n = parseFloat(v); return isNaN(n) ? '' : new Intl.NumberFormat('vi-VN').format(n) + ' ‚Ç´';
                    }
                },
                usd: {
                    label: "Ti·ªÅn t·ªá (USD)",
                    fn: (v) => {
                        const n = parseFloat(v); return isNaN(n) ? '' : '$' + n.toLocaleString('en-US');
                    }
                },
                percent: {
                    label: "Ph·∫ßn trƒÉm (%)",
                    fn: (v) => {
                        const n = parseFloat(v); return isNaN(n) ? '' : n.toFixed(2) + '%';
                    }
                },
                decimal: {
                    label: "S·ªë th·∫≠p ph√¢n (2 ch·ªØ s·ªë)",
                    fn: (v) => {
                        const n = parseFloat(v); return isNaN(n) ? '' : n.toLocaleString('vi-VN', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                    }
                },
            };

            static getFormatOptionsHTML(includeEmpty = true) {
                const opts = [];
                if (includeEmpty) {
                    opts.push(`<option value="">(M·∫∑c ƒë·ªãnh)</option>`);
                }
                for (const [key, def] of Object.entries(FormattedInput.FORMATTERS)) {
                    if (!def || typeof def !== 'object' || def.hidden) continue;
                    opts.push(`<option value="${key}">${def.label}</option>`);
                }
                return opts.join("\n");
            }

            // ===== Public API (properties) =====
            get value() { return this._rawValue; }
            set value(v) {
                const num = this._parseToNumber(v);
                this._rawValue = isNaN(num) ? '' : num;
                this._render(true);
                // ƒë·ªìng b·ªô attribute value nh∆∞ng tr√°nh v√≤ng l·∫∑p
                if (!this._updating) {
                    this._updating = true;
                    this.setAttribute('value', String(this._rawValue));
                    this._updating = false;
                }
            }

            get format() { return (this.getAttribute('format') || 'number').toLowerCase(); }
            set format(v) { this.setAttribute('format', v); }

            // ===== Lifecycle for attributes =====
            attributeChangedCallback(name, oldVal, newVal) {
                if (oldVal === newVal) return;
                if (name === 'value') {
                    if (!this._updating) this.value = newVal; // s·∫Ω parse + render
                } else if (name === 'format') {
                    this._render();
                } else if (name === 'readonly') {
                    this._updateReadonly();
                } else if (name === 'min' || name === 'max' || name === 'step') {
                    this._applyNumericAttrs();
                }
            }

            // ===== Helpers =====
            _render(initial = false) {
                const fmtDef = FormattedInput.FORMATTERS[this.format];
                const fmt = fmtDef?.fn;
                if (fmt) this._input.value = fmt(this._rawValue);
                else this._input.value = this._rawValue;
                if (!initial) this._updateReadonly();
            }
            _parseToNumber(val) {
                const cleaned = String(val ?? '').replace(/[^0-9eE+\.\-]/g, '');
                return parseFloat(cleaned);
            }
            _isReadonly() { return this.hasAttribute('readonly'); }
            _updateReadonly() {
                if (this._isReadonly()) this._input.setAttribute('readonly', 'true');
                else this._input.removeAttribute('readonly');
            }
            _isNumericFormat() { return Boolean(FormattedInput.FORMATTERS[this.format]); }
            _shouldShowSpinner() { const a = (this.getAttribute('spinner') || 'on').toLowerCase(); return this._isNumericFormat() && a !== 'off'; }
            _applyNumericAttrs() {
                if (this._input.type !== 'number') return;
                const min = this.getAttribute('min');
                const max = this.getAttribute('max');
                const step = this.getAttribute('step');
                if (min !== null) this._input.min = min; else this._input.removeAttribute('min');
                if (max !== null) this._input.max = max; else this._input.removeAttribute('max');
                if (step !== null) this._input.step = step; else this._input.removeAttribute('step');
            }
            _readNumberAttr(name, fallback) {
                const v = this.getAttribute(name);
                if (v === null || v === '') return fallback;
                const n = Number(v);
                return Number.isNaN(n) ? fallback : n;
            }
            _emitChanged() {
                this.dispatchEvent(new CustomEvent('value-changed', { detail: { value: this._rawValue }, bubbles: true, composed: true }));
            }
        }

    </script>
    <script des="app">
        // ƒêƒÉng k√Ω custom tag <auto-scroll-input>
        customElements.define("auto-scroll-input", AutoScrollInput);
        customElements.define("formatted-input", FormattedInput);
        customElements.define(ParamListView.TAGS.param_list, ParamListView);
    </script>
    <script des="controller">

        //#region View function
        function toggleBlock(id) {
            const el = document.getElementById(id);
            const title = el.previousElementSibling; // h3
            if (el.style.display === "none") {
                el.style.display = "block";
                title.innerText = title.innerText.replace("‚ûï", "‚ûñ");
            } else {
                el.style.display = "none";
                title.innerText = title.innerText.replace("‚ûñ", "‚ûï");
            }
        }

        function toggleFullscreen() {
            const btn = document.getElementById("fullscreenBtn");

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // V√†o fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                }
                btn.innerText = "‚ùé Tho√°t Fullscreen";
            } else {
                // Tho√°t fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                btn.innerText = "üî≥ V√†o Fullscreen";
            }
        }

        let isRestoring = false;

        function getCurrentWorkspaceData() {
            return {
                params: ObservableList.serialize(observableListParams),
                formulas: ObservableList.serialize(observableListFormulas)
            };
        }

        function normalizeParamData(raw) {
            if (Array.isArray(raw)) return raw;
            if (!raw || typeof raw !== "object") return [];
            return Object.entries(raw).map(([name, value]) => {
                if (value && typeof value === "object" && !Array.isArray(value)) {
                    return { name, ...value };
                }
                return { name, value };
            });
        }

        function normalizeFormulaData(raw) {
            if (Array.isArray(raw)) return raw;
            if (!raw || typeof raw !== "object") return [];
            return Object.entries(raw).map(([name, value]) => {
                if (value && typeof value === "object" && !Array.isArray(value)) {
                    return { name, ...value };
                }
                return { name, raw: value, display: value };
            });
        }

        function traverseList(list, callback) {
            if (!(list instanceof ObservableList)) return;
            list.items.forEach(item => {
                callback(item);
                if (item.children instanceof ObservableList) {
                    traverseList(item.children, callback);
                }
            });
        }

        function ensureParamListeners(item) {
            if (!item || item.children instanceof ObservableList) {
                return;
            }
            if (item._paramListenersAttached) return;

            item.registerListener(e => {
                const { field, newValue, oldValue } = e;
                if (field === "value" && newValue !== oldValue) {
                    updateFormulaResults();
                }
                persistWorkspace();
            });

            item.registerBeforeValueChangedListener(e => {
                if (e.field === "value") {
                    const parsed = parseFloat(e.newValue);
                    return isNaN(parsed) ? 0 : parsed;
                }
                return e.newValue;
            });

            item._paramListenersAttached = true;
        }

        function persistWorkspace() {
            if (isRestoring) return;
            saveToLocal();
        }

        function restoreWorkspace(data) {
            isRestoring = true;
            try {
                const normalizedParams = normalizeParamData(data?.params);
                const normalizedFormulas = normalizeFormulaData(data?.formulas);

                ObservableList.loadFromPlain(observableListParams, normalizedParams);
                ObservableList.loadFromPlain(observableListFormulas, normalizedFormulas);

                editingParamKey = null;
                document.getElementById("addParamButton").innerHTML = "Th√™m tham s·ªë";
                editingFormulaKey = null;
                document.getElementById("addFormulaButton").innerHTML = "Th√™m c√¥ng th·ª©c";

                traverseList(observableListParams, ensureParamListeners);
                updateFormulaResults();
            } finally {
                isRestoring = false;
            }

            persistWorkspace();
        }

        function exportData() {
            // H·ªèi t√™n file
            let filename = prompt("Nh·∫≠p t√™n file ƒë·ªÉ l∆∞u:", "pt-data");
            if (filename === null) return; // user b·∫•m Cancel
            filename = filename.trim() || "pt-data"; // n·∫øu b·ªè tr·ªëng th√¨ l·∫•y m·∫∑c ƒë·ªãnh

            const data = getCurrentWorkspaceData();
            saveToLocal(data);

            // T·∫°o file JSON
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename.endsWith(".json") ? filename : filename + ".json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    restoreWorkspace(data);
                    alert("Import d·ªØ li·ªáu th√†nh c√¥ng!");
                } catch (err) {
                    alert("File kh√¥ng h·ª£p l·ªá: " + err.message);
                }
            };
            reader.readAsText(file);
        }
        //#region X·ª≠ l√Ω layout divider
        const divider = document.getElementById("divider");
        const mainContainer = document.getElementById("mainContainer");
        const paramContainer = document.getElementById("paramContainer");

        let isResizing = false;

        divider.addEventListener("mousedown", startResize);
        divider.addEventListener("touchstart", startResize, { passive: false });

        function startResize(e) {
            isResizing = true;
            document.body.classList.add("mouse-effect-no-select");
            document.addEventListener("mousemove", resize);
            document.addEventListener("mouseup", stopResize);
            document.addEventListener("touchmove", resize, { passive: false });
            document.addEventListener("touchend", stopResize);
        }

        function resize(e) {
            if (!isResizing) return;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;

            // T√≠nh t·ªça ƒë·ªô X t∆∞∆°ng ƒë·ªëi trong container
            const rect = mainContainer.getBoundingClientRect();
            const dividerWidth = divider.getBoundingClientRect().width;
            let x = clientX - rect.left;               // px t·ª´ m√©p tr√°i container
            let newWidth = ((x - dividerWidth / 2) / rect.width) * 100;     // ƒë·ªïi sang %

            // Gi·ªõi h·∫°n min‚Äìmax
            const MIN_PCT = 30, MAX_PCT = 60;
            if (newWidth < MIN_PCT) newWidth = MIN_PCT;
            if (newWidth > MAX_PCT) newWidth = MAX_PCT;

            // Set flex-basis ƒë·ªÉ ƒë·ªïi chi·ªÅu r·ªông c·ªôt tr√°i
            paramContainer.style.flexBasis = `${newWidth}%`;

            // NgƒÉn scroll khi k√©o tr√™n mobile
            if (e.cancelable) e.preventDefault();

            // Debug
            // console.log("x=", x, "rect.width=", rect.width, "newWidth%=", newWidth);
        }

        function stopResize() {
            isResizing = false;
            document.body.classList.remove("mouse-effect-no-select");
            document.removeEventListener("mousemove", resize);
            document.removeEventListener("mouseup", stopResize);
            document.removeEventListener("touchmove", resize);
            document.removeEventListener("touchend", stopResize);
        }
        //#endregion

        //#endregion

        //#region Utils
        function formatValue(val, format) {
            console.log("formatValue");

            if (val == null || isNaN(val)) return val;

            const fmt = FormattedInput.FORMATTERS[format]?.fn;
            return typeof fmt === "function" ? fmt(val) : val;
        }
        //#endregion

        //#region List Context Menu
        let currentType = null;
        let currentName = null;
        const menu = document.getElementById("contextMenu");

        const MENU_ACTIONS = {
            param: [
                { icon: "‚úèÔ∏è", label: "Edit", action: (name) => editParam(name) },
                { icon: "‚ùå", label: "Delete", action: (name) => deleteParam(name) }
            ],
            formula: [
                { icon: "‚úèÔ∏è", label: "Edit", action: (name) => editFormula(name) },
                { icon: "‚ùå", label: "Delete", action: (name) => deleteFormula(name) }
            ]
        };
        function handleContextMenu(e) {
            const { item, x, y, extraParam } = e.detail;
            console.log("üü† Context menu:", item.name, x, y);
            const type = extraParam[0]
            const itemName = item.name
            // Build menu items theo type
            menu.innerHTML = MENU_ACTIONS[type]
                .map(item => `
      <div class="context-menu-item" onclick="handleContext('${item.label}', '${type}', '${itemName}')">
        ${item.icon} ${item.label}
      </div>
    `).join("");

            menu.style.display = "block";
            menu.style.left = x + "px";
            menu.style.top = y + "px";
        }

        function handleContext(label, type, itemName) {
            if (!type || !itemName) return;
            const item = MENU_ACTIONS[type].find(x => x.label === label);
            if (item) item.action(itemName);
            menu.style.display = "none";
        }

        // ·∫®n menu khi click ra ngo√†i
        document.addEventListener("click", () => menu.style.display = "none");

        //#endregion 

        //#region Param
        const observableListParams = new ObservableList([]);
        const paramIndexer = new ObservableIndexer(observableListParams, "name");

        const paramsView = document.getElementById("paramsView");
        paramsView.data = observableListParams;

        let editingParamKey = null;

        function editParam(key) {
            p = paramIndexer.get(key);
            if (!p) return;

            // Fill input
            document.getElementById("paramName").value = key;
            document.getElementById("paramValue").value = p.value;
            if (p.groupName) {
                document.getElementById("paramGroup").value = p.groupName;
            }
            document.getElementById("paramColor").value = p.color;
            document.getElementById("paramDesc").value = p.desc || "";
            document.getElementById("paramFormat").value = p.format;
            document.getElementById("addParamButton").innerHTML = "C·∫≠p nh·∫≠t";
            editingParamKey = key; // ƒë√°nh d·∫•u ƒëang edit
        }

        function addParam() {
            const name = document.getElementById("paramName").value.trim();
            const value = parseFloat(document.getElementById("paramValue").value);
            const desc = document.getElementById("paramDesc").value.trim();
            const group = document.getElementById("paramGroup").value.trim();
            const color = document.getElementById("paramColor").value;
            const format = document.getElementById("paramFormat").value;

            if (!name) { alert("T√™n param kh√¥ng ƒë∆∞·ª£c r·ªóng!"); return; }
            if (isNaN(value)) { alert("Gi√° tr·ªã ph·∫£i l√† s·ªë!"); return; }


            if (paramIndexer.has(name) && editingParamKey == null) {
                alert(`Param ${name} ƒë√£ t·ªìn t·∫°i!`); return;
            }

            if (editingParamKey) {
                oldItem = paramIndexer.get(editingParamKey);
                oldGroupName = oldItem.groupName;
                oldItem.name = name;
                oldItem.value = value;
                oldItem.desc = desc;
                oldItem.format = format;
                editingParamKey = null;
                if (group != '' && group != oldGroupName) {
                    if (oldItem.parent) {
                        oldItem.parent.remove(oldItem);
                    }
                    newGroup = observableListParams.addNewGroup(group);
                    newGroup.children.push(oldItem);
                    oldItem.groupName = group;
                }
                document.getElementById("addParamButton").innerHTML = "Th√™m tham s·ªë";
            } else {
                const newItem = new ObservableListItem({
                    name,
                    value,
                    desc,
                    color,
                    format
                });
                observableListParams.addToGroup(group, newItem);
                ensureParamListeners(newItem);
            }

            document.getElementById("paramName").value = "";
            document.getElementById("paramValue").value = "";
            document.getElementById("paramDesc").value = "";
            document.getElementById("paramGroup").value = "";
            document.getElementById("paramColor").value = "#f0f0f0";

            persistWorkspace();
        }

        function deleteParam(key) {
            param = paramIndexer.get(key);
            if (param) {
                param.parent.remove(param);
            }
            updateFormulaResults();
            persistWorkspace();
        }

        //#endregion

        //#region Formula
        const observableListFormulas = new ObservableList([]);
        const formulaIndexer = new ObservableIndexer(observableListFormulas, "name");

        const formulasView = document.getElementById("formulasView");
        formulasView.data = observableListFormulas;
        let editingFormulaKey = null;

        // Format c√¥ng th·ª©c: th√™m kho·∫£ng tr·∫Øng v√† ƒë·ªïi * th√†nh √ó
        function formatFormulaDisplay(formula) {
            return formula
                .replace(/\*/g, "√ó")              // ƒë·ªïi d·∫•u nh√¢n
                .replace(/\//g, "√∑")              // c√≥ th·ªÉ ƒë·ªïi d·∫•u chia
                .replace(/([\+\-\√ó√∑])/g, " $1 ")  // th√™m kho·∫£ng tr·∫Øng quanh to√°n t·ª≠
                .replace(/\s+/g, " ")             // g·ªôp nhi·ªÅu kho·∫£ng tr·∫Øng th√†nh 1
                .trim();
        }

        function deleteFormula(key) {
            formula = formulaIndexer.get(key);
            if (formula) {
                formula.parent.remove(formula);
            }
            updateFormulaResults();
            persistWorkspace();
        }

        function editFormula(key) {
            p = formulaIndexer.get(key);
            if (!p) return;

            // Fill input
            document.getElementById("formulaName").value = key;
            document.getElementById("formulaDesc").value = p.desc;
            if (p.groupName) {
                document.getElementById("formulaGroup").value = p.groupName;
            }
            document.getElementById("formulaInput").value = p.raw;
            document.getElementById("addFormulaButton").innerHTML = "C·∫≠p nh·∫≠t";
            editingFormulaKey = key; // ƒë√°nh d·∫•u ƒëang edit
        }

        function addFormula() {
            const nameInput = document.getElementById("formulaName").value.trim();
            let name = nameInput;
            if (!name) {
                let counter = 1;
                do {
                    name = `C${counter++}`;
                } while (formulaIndexer.has(name));
            }
            const formula = document.getElementById("formulaInput").value.trim();
            const desc = document.getElementById("formulaDesc").value.trim();
            const group = document.getElementById("formulaGroup").value.trim();

            if (!formula) { alert("Ch∆∞a nh·∫≠p c√¥ng th·ª©c!"); return; }

            if (formulaIndexer.has(name) && editingFormulaKey == null) {
                alert(`C√¥ng th·ª©c ${name} ƒë√£ t·ªìn t·∫°i!`); return;
            }
            if (editingFormulaKey) {
                oldItem = formulaIndexer.get(editingFormulaKey);
                oldGroupName = oldItem.groupName;
                oldItem.name = name;
                oldItem.raw = formula;
                oldItem.desc = desc;
                oldItem.display = formula;
                editingFormulaKey = null;
                if (group != '' && group != oldGroupName) {
                    if (oldItem.parent) {
                        oldItem.parent.remove(oldItem);
                    }
                    newGroup = observableListFormulas.addNewGroup(group);
                    newGroup.children.push(oldItem);
                    oldItem.groupName = group;
                }
                document.getElementById("addFormulaButton").innerHTML = "Th√™m c√¥ng th·ª©c";
            } else {
                const newItem = new ObservableListItem({
                    name: name,
                    raw: formula,
                    desc: desc,
                    display: formula,
                    result: "1"
                });

                observableListFormulas.addToGroup(group, newItem);
            }

            updateFormulaResults();

            document.getElementById("formulaName").value = "";
            document.getElementById("formulaInput").value = "";
            document.getElementById("formulaDesc").value = "";
            document.getElementById("formulaGroup").value = "";

            persistWorkspace();
        }

        // T√≠nh to√°n l·∫°i t·∫•t c·∫£ c√¥ng th·ª©c
        function updateFormulaResults() {
            let scope = {};
            // 1) Map params -> scope (l·∫•y field value n·∫øu l√† object)
            for (let [k, v] of paramIndexer.entries()) {
                if (v && v.children instanceof ObservableList) continue;
                scope[k] = (v && typeof v === "object" && "value" in v) ? v.value : v;
            }

            // 2) Ti√™m alias c√°c h√†m/const to√°n h·ªçc ph·ªï bi·∫øn v√†o scope
            const MATH_ALIASES = {
                ceil: Math.ceil,
                floor: Math.floor,
                round: Math.round,
                min: Math.min,
                max: Math.max,
                pow: Math.pow,
                abs: Math.abs,
                sqrt: Math.sqrt,
                log: Math.log,
                exp: Math.exp,
                sin: Math.sin,
                cos: Math.cos,
                tan: Math.tan,
                asin: Math.asin,
                acos: Math.acos,
                atan: Math.atan,
                atan2: Math.atan2,
                trunc: Math.trunc,
                random: Math.random,
                PI: Math.PI,
                E: Math.E
            };
            Object.assign(scope, MATH_ALIASES);

            // T·∫≠p t√™n ‚Äúƒë∆∞·ª£c ph√©p‚Äù ƒë·ªÉ kh√¥ng b·ªã highlight thi·∫øu
            const ALLOWED_NAMES = new Set([...Object.keys(scope), "Math"]);

            for (let [name, f] of formulaIndexer.entries()) {
                if (f && f.children instanceof ObservableList) continue;
                try {
                    let keys = Object.keys(scope);
                    let values = Object.values(scope);

                    // Evaluate c√¥ng th·ª©c
                    let func = new Function(...keys, `return ${f.raw};`);
                    let result = func(...values);

                    // L∆∞u k·∫øt qu·∫£ v√†o scope ƒë·ªÉ c√°c c√¥ng th·ª©c sau c√≥ th·ªÉ d√πng ti·∫øp
                    scope[name] = result;
                    formulaIndexer.get(name)['result'] = result;
                    // Render UI

                } catch (e) {
                    // B·∫Øt t√™n bi·∫øn/h√†m trong raw
                    const tokens = f.raw.match(/[a-zA-Z_]\w*/g) || [];
                    // L·ªçc ra nh·ªØng t√™n ch∆∞a c√≥ trong scope v√† kh√¥ng thu·ªôc allowed (Math funcs/const)
                    const missing = tokens.filter(t => !ALLOWED_NAMES.has(t));

                    if (missing.length > 0) {
                        // highlight ƒë·ªè c√°c bi·∫øn thi·∫øu trong display
                        const highlighted = f.display.replace(
                            new RegExp("\\b(" + missing.join("|") + ")\\b", "g"),
                            '<span style="color:red;font-weight:bold;">$1</span>'
                        );
                        document.getElementById("formulaDisplay_" + name).innerHTML = highlighted;
                        document.getElementById("formulaResult_" + name).innerText =
                            " (Thi·∫øu: " + missing.join(", ") + ")";
                    } else if (/Unexpected/.test(e.message)) {
                        document.getElementById("formulaResult_" + name).innerText = " (L·ªói c√∫ ph√°p)";
                    } else {
                        document.getElementById("formulaResult_" + name).innerText = " (L·ªói: " + e.message + ")";
                    }
                }
            }
        }

        //#endregion

        // L∆∞u local m·ªói khi c√≥ thay ƒë·ªïi
        function clearWorkspace() {
            if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën xo√° to√†n b·ªô Param v√† Formula hi·ªán t·∫°i kh√¥ng?")) return;

            observableListParams.splice(0, observableListParams.items.length);
            observableListFormulas.splice(0, observableListFormulas.items.length);
            editingParamKey = null;
            document.getElementById("addParamButton").innerHTML = "Th√™m tham s·ªë";
            editingFormulaKey = null;
            document.getElementById("addFormulaButton").innerHTML = "Th√™m c√¥ng th·ª©c";
            updateFormulaResults();
            persistWorkspace();
        }

        function saveToLocal(data = null) {
            const payload = data || getCurrentWorkspaceData();
            localStorage.setItem("pt-latest-data", JSON.stringify(payload));
        }

        // Load khi m·ªü page
        function loadFromLocal() {
            const raw = localStorage.getItem("pt-latest-data");
            if (!raw) return;
            try {
                const data = JSON.parse(raw);
                restoreWorkspace(data);
            } catch (e) {
                console.error("Kh√¥ng load ƒë∆∞·ª£c d·ªØ li·ªáu local:", e);
            }
        }

        // G·ªçi khi page kh·ªüi ƒë·ªông
        window.addEventListener("DOMContentLoaded", () => {
            const formatOptionsHTML = FormattedInput.getFormatOptionsHTML();

            const paramFormatSelect = document.getElementById("paramFormat");
            if (paramFormatSelect) {
                paramFormatSelect.innerHTML = formatOptionsHTML;
            }

            const formulaFormatSelect = document.getElementById("formulaFormat");
            if (formulaFormatSelect) {
                formulaFormatSelect.innerHTML = formatOptionsHTML;
            }
            loadFromLocal();
        });


        // L∆∞u tr·∫°ng th√°i workspace ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong persistWorkspace()

    </script>
    <script>
        function handleItemClick(e) {
            const { item } = e.detail;
            // alert("üü¢ Clicked: " + item.name);
        }

        function handleGroupToggle(e) {
            const { group, expanded } = e.detail;
            // console.log(`üìÇ Group ${group.name} is now ${expanded ? "expanded" : "collapsed"}`);
        }
    </script>
</body>

</html>