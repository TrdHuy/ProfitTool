<!DOCTYPE html>
<html lang="vi">

<head>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <meta charset="UTF-8">
    <title>Param Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <style>
        body {
            font-family: 'Inter', 'Roboto', sans-serif;
            font-size: 14px;
            color: #333;
            padding: 20px;
            margin: auto;
        }

        h2,
        h3 {
            text-align: center;
        }

        /* #region list-item*/
        /* Param v√† Formula item chung */
        .param-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-radius: 4px;
            margin: 3px 0;
            background: var(--list-item-bg, #fafafa);
            /* default m√†u */
            transition: background 0.2s, transform 0.1s;
        }

        .param-item:hover {
            background: #f5faff;
        }

        .param-item:active {
            background: #dbe9ff;
            transform: scale(0.98);
        }

        .group-header {
            font-weight: bold;
            cursor: pointer;
            background: #eee;
            padding: 4px;
            border-radius: 4px;
        }

        .group-children {
            margin-left: 20px;
        }

        /* #endregion */
        .block {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .scroll-box {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 5px;
            margin-top: 10px;
            border-radius: 4px;
            background: #fafafa;
        }

        label {
            display: block;
            margin-top: 5px;
        }

        input {
            padding: 5px;
            margin: 3px 0;
        }

        button {
            margin-top: 10px;
            padding: 6px 12px;
        }

        .formula-result {
            font-weight: bold;
            color: darkblue;
        }

        .group-header {
            background: #eee;
            padding: 5px;
            margin-top: 5px;
            border-radius: 4px;
            cursor: pointer;
        }

        .group-header:hover {
            background: #ddd;
        }


        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menubar {
            display: flex;
            gap: 10px;
            background: #f0f0f0;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 15px;
            align-items: center;
        }

        /* Style n√∫t */
        .menubar button,
        .menubar .menu-btn {
            margin: 2px;
            background: #ffffff;
            border: 1px solid #bbb;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s, box-shadow 0.2s;
        }

        /* Hover effect */
        .menubar button:hover,
        .menubar .menu-btn:hover {
            background: #e6f0ff;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        }

        .context-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-width: 120px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1000;
        }

        .context-menu-item {
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        /* ·∫®n input file th·∫≠t, ch·ªâ show label gi·∫£ n√∫t */
        #importFile {
            display: none;
        }

        .formula-block {
            flex: 1;
            /* t·ª± chi·∫øm ph·∫ßn c√≤n l·∫°i */
        }

        .mouse-effect-no-select {
            user-select: none;
            /* chu·∫©n */
            -webkit-user-select: none;
            /* Safari/Chrome */
            -ms-user-select: none;
            /* IE/Edge c≈© */
        }

        /* Khi xoay ngang (chi·ªÅu r·ªông > chi·ªÅu cao) th√¨ ƒë·ªïi layout ngang */
        /* Mobile th∆∞·ªùng c√≥ pointer: coarse (ng√≥n tay), c√≤n PC l√† fine (chu·ªôt) */
        @media (orientation: landscape) {
            .container {
                display: flex;
                flex-direction: row;
                height: 100%;
                gap: 0px;
            }

            .divider {
                width: 30px;
                cursor: col-resize;
                background: #ddd;
            }

            .divider:hover {
                background: #aaa;
            }

            .param-block {
                min-width: 30%;
                max-width: 60%;
            }
        }

        @media (orientation: landscape) and (pointer: coarse) {
            .container {
                display: flex;
                flex-direction: row;
                height: 100%;
                gap: 0px;
            }

            .divider {
                width: 10px;
                cursor: col-resize;
                background: #ddd;
            }

            .divider:hover {
                background: #aaa;
            }

            .param-block {
                min-width: 30%;
                max-width: 60%;
            }
        }
    </style>
</head>

<body>
    <h2>Param Editor</h2>
    <div class="menubar">
        <button onclick="exportData()">üíæ Export</button>

        <label for="importFile" class="menu-btn">üìÇ Import</label>
        <input type="file" id="importFile" accept=".json" onchange="importData(this)">
        <button onclick="clearWorkspace()">üßπ Clear</button>
        <button onclick="toggleFullscreen()">üî≥ Toggle Fullscreen</button>

    </div>
    <div class="container" id="mainContainer">
        <!-- Th√™m tham s·ªë -->
        <div class="block param-block" id="paramContainer">
            <h3 onclick="toggleBlock('paramBlock')" style="cursor:pointer;">
                ‚ûï Th√™m tham s·ªë
            </h3>

            <div id="paramBlock">
                <label>T√™n param:</label>
                <auto-scroll-input type="text" id="paramName" placeholder="V√≠ d·ª•: A"></auto-scroll-input>
                <label>M√¥ t·∫£:</label>
                <auto-scroll-input type="text" id="paramDesc" placeholder="V√≠ d·ª•: s·ªë l∆∞·ª£ng m√°y"></auto-scroll-input>
                <label>Gi√° tr·ªã:</label>
                <auto-scroll-input type="number" id="paramValue" placeholder="V√≠ d·ª•: 10"></auto-scroll-input>
                <label>Group:</label>
                <auto-scroll-input type="text" id="paramGroup" placeholder="V√≠ d·ª•: Nh√¢n s·ª±"></auto-scroll-input>

                <label>M√†u n·ªÅn:</label>
                <input type="color" id="paramColor" value="#f0f0f0">

                <label>Format:</label>
                <select id="paramFormat">
                    <option value="">(M·∫∑c ƒë·ªãnh)</option>
                    <option value="currency">Ti·ªÅn t·ªá (VND)</option>
                    <option value="decimal">S·ªë th·∫≠p ph√¢n</option>
                    <option value="percent">Ph·∫ßn trƒÉm</option>
                </select>

                <button onclick="addParam()" id="addParamButton">Th√™m tham s·ªë</button>
            </div>
            <param-list id="paramsView" onitemclick="handleItemClick" onitemcontextmenu="handleContextMenu('param')"
                ongrouptoggle="handleGroupToggle">
                <template>
                    <div class="param-item">
                        <div style="display: block;">
                            <span>{{name}}</span> =
                            <input type="number" value="{{value}}">
                            <div style="font-size:12px; color:#666;">{{desc}}</div>
                        </div>
                    </div>

                </template>
            </param-list>
        </div>

        <div class="divider" id="divider"></div>
        <!-- Th√™m c√¥ng th·ª©c -->
        <div class="block formula-block" id="formulaContainer">
            <h3>Th√™m c√¥ng th·ª©c</h3>
            <label>T√™n c√¥ng th·ª©c:</label>
            <auto-scroll-input type="text" id="formulaName" placeholder="V√≠ d·ª•: Doanh thu"></auto-scroll-input>
            <label>M√¥ t·∫£:</label>
            <auto-scroll-input type="text" id="formulaDesc"
                placeholder="V√≠ d·ª•: doanh thu h√†ng th√°ng"></auto-scroll-input>
            <label>Group:</label>
            <auto-scroll-input type="text" id="formulaGroup" placeholder="V√≠ d·ª•: doanh thu"></auto-scroll-input>
            <label>C√¥ng th·ª©c:</label>
            <auto-scroll-input type="text" id="formulaInput" placeholder="V√≠ d·ª•: A + B * 2"></auto-scroll-input>
            <button onclick="addFormula()" id="addFormulaButton">Th√™m c√¥ng th·ª©c</button>
            <param-list id="formulasView" onitemclick="handleItemClick" onitemcontextmenu="handleContextMenu('formula')"
                ongrouptoggle="handleGroupToggle">
                <template>
                    <div class="param-item">
                        <div style="display: block;">
                            <span>{{name}}: {{display}}</span> =
                            <span>{{result}}</span>
                            <div style="font-size:12px; color:#666;">{{desc}}</div>
                        </div>
                    </div>
                </template>
            </param-list>
        </div>


    </div>
    <div id="contextMenu" class="context-menu">
    </div>
    <script des="definition">
        const isMobile = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent);
    </script>
    <script des="utils">
        class ObservableListItem {
            constructor(data = {}, children = null) {
                // Copy to√†n b·ªô field t·ª´ dict v√†o object
                Object.assign(this, data);

                // T·∫°o danh s√°ch con n·∫øu c√≥
                if (children instanceof ObservableList) {
                    this.children = children;
                } else if (Array.isArray(children)) {
                    this.children = new ObservableList(children);
                } else if (Array.isArray(data.children)) {
                    this.children = new ObservableList(data.children);
                } else if (data.children instanceof ObservableList) {
                    this.children = data.children;
                } else {
                    this.children = null;
                }

                // ‚úÖ G√°n parent cho children n·∫øu c√≥
                if (this.children) {
                    this.children._parent = this;
                }

                const self = this;
                const proxy = new Proxy(this, {
                    set(target, prop, value) {
                        const oldValue = target[prop];
                        const changed = oldValue !== value;
                        if (
                            changed &&
                            prop !== "parent" &&
                            prop !== "children" &&
                            typeof prop === "string"
                        ) {

                            // N·∫øu item c√≥ listener ri√™ng
                            if (self._beforeValueChangedlisteners && self._beforeValueChangedlisteners.size > 0) {
                                self._beforeValueChangedlisteners.forEach(cb =>
                                    value = cb({ field: prop, oldValue, newValue: value, item: proxy }) || value
                                );
                            }
                        }
                        // g√°n gi√° tr·ªã
                        target[prop] = value;

                        // n·∫øu gi√° tr·ªã thay ƒë·ªïi v√† kh√¥ng ph·∫£i internal field ‚Üí ph√°t s·ª± ki·ªán
                        if (
                            changed &&
                            prop !== "parent" &&
                            prop !== "children" &&
                            typeof prop === "string"
                        ) {

                            // N·∫øu item c√≥ listener ri√™ng
                            if (self._valueChangedListeners && self._valueChangedListeners.size > 0) {
                                self._valueChangedListeners.forEach(cb =>
                                    cb({ field: prop, oldValue, newValue: value, item: proxy })
                                );
                            }
                        }

                        return true;
                    },
                    get(target, prop) {
                        return target[prop];
                    },
                });
                // l∆∞u set listener ri√™ng cho item n·∫øu c·∫ßn
                proxy._valueChangedListeners = new Set();
                proxy._beforeValueChangedlisteners = new Set();
                proxy.registerListener = cb => proxy._valueChangedListeners.add(cb);
                proxy.unregisterListener = cb => proxy._valueChangedListeners.delete(cb);
                proxy.registerBeforeValueChangedListener = cb => proxy._beforeValueChangedlisteners.add(cb);
                proxy.unregisterBeforeValueChangedListener = cb => proxy._beforeValueChangedlisteners.delete(cb);


                return proxy;
            }

            toString() {
                return this.name ?? JSON.stringify(this);
            }
        }

        class ObservableList {
            constructor(items = [], parent = null) {
                this._items = items;
                this._listeners = new Set();      // collection listeners
                this._itemListeners = new Set();  // item change listeners
                this._parent = parent; // list cha (c√≥ th·ªÉ l√† list g·ªëc ho·∫∑c group con)

                const proxy = new Proxy(this, {
                    get: (target, prop) => {
                        if (prop === "registerListener") return cb => target._listeners.add(cb);
                        if (prop === "unregisterListener") return cb => target._listeners.delete(cb);

                        if (prop === "registerItemListener") return cb => target._itemListeners.add(cb);
                        if (prop === "unregisterItemListener") return cb => target._itemListeners.delete(cb);

                        if (prop === "addToGroup") {
                            return (groupName, item) => {
                                if (!(item instanceof ObservableListItem)) {
                                    throw new Error("addToGroup() expects an ObservableListItem instance.");
                                }

                                // N·∫øu kh√¥ng nh·∫≠p group name ‚Üí th√™m th·∫≥ng v√†o root
                                if (!groupName) {
                                    proxy.push(item);
                                    return;
                                }

                                // H√†m ƒë·ªá quy t√¨m group theo t√™n trong to√†n b·ªô c√¢y
                                function findGroupRecursive(list, name) {
                                    for (const it of list.items) {
                                        if (it.name === name && it.children instanceof ObservableList) return it;
                                        if (it.children) {
                                            const found = findGroupRecursive(it.children, name);
                                            if (found) return found;
                                        }
                                    }
                                    return null;
                                }

                                let group = findGroupRecursive(proxy, groupName);

                                if (!group) {
                                    // N·∫øu ch∆∞a c√≥ group ‚Üí t·∫°o m·ªõi ·ªü root
                                    group = new ObservableListItem({
                                        name: groupName,
                                        expanded: true,
                                        children: new ObservableList([], proxy)
                                    });
                                    proxy.push(group);
                                }

                                // Th√™m item v√†o trong group
                                if (!group.children) {
                                    group.children = new ObservableList([], proxy);
                                }
                                group.children.push(item);
                            };
                        }

                        if (prop === "push") {
                            return (...args) => {
                                args.forEach(it => {
                                    if (!(it instanceof ObservableListItem)) {
                                        throw new Error("push() expects only ObservableListItem instances.");
                                    }
                                    it.parent = proxy;
                                });
                                const startIndex = target._items.length;
                                const result = target._items.push(...args);
                                args.forEach((item, i) =>
                                    target._notifyCollection({ action: "add", index: startIndex + i, item })
                                );
                                return result;
                            };
                        }

                        if (prop === "set") {
                            return (i, val) => {
                                if (!(val instanceof ObservableListItem)) {
                                    throw new Error("set() expects an ObservableListItem instance.");
                                }
                                val.parent = proxy;
                                const oldItem = target._items[i];
                                target._items[i] = val;
                                target._notifyCollection({ action: "set", oldItem, newItem: val });
                            };
                        }

                        if (prop === "remove") {
                            return (item) => {
                                const index = target._items.indexOf(item);
                                if (index === -1) return false; // kh√¥ng t√¨m th·∫•y

                                // X√≥a item kh·ªèi danh s√°ch
                                const removed = target._items.splice(index, 1);
                                removed.forEach(it => (it.parent = null));

                                // G·ª≠i s·ª± ki·ªán th√¥ng b√°o
                                target._notifyCollection({
                                    action: "remove",
                                    index,
                                    items: removed
                                });

                                return true;
                            };
                        }

                        if (prop === "splice") {
                            return (start, deleteCount, ...itemsToAdd) => {
                                itemsToAdd.forEach(it => {
                                    if (!(it instanceof ObservableListItem)) {
                                        throw new Error("splice() expects only ObservableListItem instances.");
                                    }
                                    it.parent = proxy;
                                });

                                const removed = target._items.splice(start, deleteCount, ...itemsToAdd);
                                removed.forEach(it => (it.parent = null));

                                // G·ª≠i s·ª± ki·ªán thay ƒë·ªïi
                                if (removed.length > 0 && itemsToAdd.length === 0) {
                                    target._notifyCollection({ action: "remove", index: start, items: removed });
                                } else if (removed.length === 0 && itemsToAdd.length > 0) {
                                    itemsToAdd.forEach((it, i) =>
                                        target._notifyCollection({ action: "add", index: start + i, item: it })
                                    );
                                } else {
                                    target._notifyCollection({
                                        action: "splice",
                                        index: start,
                                        removed,
                                        added: itemsToAdd
                                    });
                                }

                                return removed;
                            };
                        }


                        if (prop === "parent") return target._parent;
                        if (prop === "items") return target._items;
                        if (prop === "notifyCollection") return e => target._notify(e);
                        return target._items[prop];
                    }
                });

                // ‚úÖ set parent ƒë√∫ng proxy cho t·∫•t c·∫£ item ban ƒë·∫ßu
                this._items.forEach(it => {
                    if (!(it instanceof ObservableListItem)) {
                        console.error("Invalid item:", it);
                        throw new Error("All items in ObservableList must be instances of ObservableListItem.");
                    }
                    it.parent = proxy;
                });

                return proxy;
            }
            _notifyCollection(e) { this._listeners.forEach(cb => cb(e)); }
            _notifyItem(e) { this._itemListeners.forEach(cb => cb(e)); }
        }

        class ObservableIndexer {
            constructor(observableList, keyField = "name", recursive = true) {
                this._keyField = keyField;
                this._index = new Map();          // key ‚Üí item
                this._rootList = observableList;  // root list ƒëang theo d√µi
                this._recursive = recursive;

                // ƒêƒÉng k√Ω listener
                observableList.registerListener(e => this._onCollectionChanged(e));

                // Kh·ªüi t·∫°o index ban ƒë·∫ßu
                this._buildIndex(observableList);
            }

            _buildIndex(list) {
                for (const item of list.items) {
                    this._tryAdd(item);
                    if (this._recursive && item.children instanceof ObservableList) {
                        this._buildIndex(item.children);
                    }
                }
            }

            _onCollectionChanged(e) {
                if (e.action === "add") {
                    this._tryAdd(e.item);
                } else if (e.action === "remove") {
                    e.items.forEach(it => this._remove(it));
                } else if (e.action === "splice") {
                    e.removed.forEach(it => this._remove(it));
                    e.added.forEach(it => this._tryAdd(it));
                } else if (e.action === "set") {
                    this._remove(e.oldItem);
                    this._tryAdd(e.newItem);
                }

                // N·∫øu c√≥ children th√¨ c≈©ng c·∫ßn theo d√µi recursive
                if (this._recursive) {
                    const items = e.items || [e.item].filter(Boolean);
                    items.forEach(it => {
                        if (it.children instanceof ObservableList) {
                            it.children.registerListener(ev => this._onCollectionChanged(ev));
                            this._buildIndex(it.children);
                        }
                    });
                }
            }

            _tryAdd(item) {
                const key = item[this._keyField];
                if (key == null) return;
                this._index.set(key, item);

                // Theo d√µi rename ƒë·ªông (n·∫øu c√≥ setter trigger)
                if (Object.getOwnPropertyDescriptor(Object.getPrototypeOf(item), this._keyField) == null) {
                    // n·∫øu ch∆∞a c√≥ getter/setter th√¨ th√™m dynamic watcher
                    let val = key;
                    Object.defineProperty(item, this._keyField, {
                        get() { return val; },
                        set: newVal => {
                            const oldVal = val;
                            val = newVal;
                            this._onItemKeyChanged(item, oldVal, newVal);
                        },
                        configurable: true,
                        enumerable: true,
                    });
                }
            }

            _remove(item) {
                const key = item[this._keyField];
                if (key != null && this._index.get(key) === item) {
                    this._index.delete(key);
                }
                if (this._recursive && item.children instanceof ObservableList) {
                    for (const child of item.children.items) {
                        this._remove(child);
                    }
                }
            }

            _onItemKeyChanged(item, oldKey, newKey) {
                if (this._index.get(oldKey) === item) this._index.delete(oldKey);
                this._index.set(newKey, item);
            }

            // API public
            get(key) { return this._index.get(key) || null; }
            has(key) { return this._index.has(key); }
            delete(key) { return this._index.delete(key); }
            keys() { return Array.from(this._index.keys()); }
            values() { return Array.from(this._index.values()); }
            entries() { return Array.from(this._index.entries()); }
        }

    </script>
    <script des="views">

        class ParamListView extends HTMLElement {
            static TAGS = {
                item_template: "template",
                param_list: "param-list"
            };
            static CLASSES = {
                item: "param-item",
                groupBlock: "group-block",
                groupHeader: "group-header",
                groupChildren: "group-children",
            };
            constructor() {
                super();
                this._data = null;
                this._itemElems = new Map();
                this._onCollectionChanged = this.onCollectionChanged.bind(this);
            }


            set data(list) {
                if (this._data) this._data.unregisterListener(this._onCollectionChanged);
                this._data = list;
                if (list) list.registerListener(this._onCollectionChanged);
                this.renderAll();
            }
            get data() { return this._data; }

            get rootView() {
                return this._rootView || this; // fallback v·ªÅ ch√≠nh n√≥ n·∫øu ch∆∞a c√≥
            }
            set rootView(v) {
                this._rootView = v;
            }
            get itemElems() {
                return this.rootView._itemElems
            }

            renderAll() {
                const C = ParamListView.CLASSES;
                const T = ParamListView.TAGS;

                this.querySelectorAll(`.${C.item}, .${C.groupBlock}`).forEach(el => el.remove());
                if (this === this.rootView) {
                    this._itemElems.clear();
                }

                if (!this._data) return;
                const template = this.querySelector(T.item_template);
                if (!template) return;

                this._data.items.forEach(p => {
                    const elem = this._createItemElement(p);
                    this.appendChild(elem);
                    this.itemElems.set(p, elem);
                });
            }

            onCollectionChanged(e) {
                console.log("onCollectionChanged:", { e });
                switch (e.action) {
                    case "add":
                        this._handleAdd(e);
                        break;

                    case "remove":
                        this._handleRemove(e);
                        break;

                    case "set":
                        this._handleSet(e);
                        break;

                    case "splice":
                        this._handleSplice(e);
                        break;
                }
            }

            _isAncestor(ancestor, node) {
                if (!ancestor || !node || ancestor === node) return false;

                let current = node.parent;
                while (current) {
                    if (current === ancestor) return true;
                    // N·∫øu current l√† ObservableList th√¨ nh·∫£y ti·∫øp l√™n cha c·ªßa list ƒë√≥ (n·∫øu c√≥)
                    if (current.parent) {
                        current = current.parent;
                    } else {
                        // current l√† item nh∆∞ng kh√¥ng c√≥ parent list
                        break;
                    }
                }
                return false;
            }


            _getItemElements() {
                const C = ParamListView.CLASSES;
                return Array.from(this.children).filter(
                    el => el.classList.contains(C.item) || el.classList.contains(C.groupBlock)
                );
            }

            _handleAdd(e) {
                const elem = this._createItemElement(e.item);
                const itemElems = this._getItemElements();
                const refElem = itemElems[e.index];
                if (refElem) this.insertBefore(elem, refElem);
                else this.appendChild(elem);
                this.itemElems.set(e.item, elem);
            }

            _handleRemove(e) {
                // e.items c√≥ th·ªÉ l√† m·∫£ng item b·ªã xo√°
                const removedItems = e.items || (e.item ? [e.item] : []);
                removedItems.forEach(item => {
                    const elem = this.itemElems.get(item);
                    if (elem) {
                        elem.remove();
                        this.itemElems.delete(item);
                    }
                });
            }

            _handleSet(e) {
                const oldElem = this.itemElems.get(e.oldItem);
                if (oldElem) {
                    const newElem = this._createItemElement(e.newItem);
                    oldElem.replaceWith(newElem);
                    this.itemElems.delete(e.oldItem);
                    this.itemElems.set(e.newItem, newElem);
                }
            }

            /**
             * e = { action: "splice", index, removed, added }
             */
            _handleSplice(e) {
                // 1Ô∏è‚É£ X√≥a ph·∫ßn t·ª≠ c≈© (n·∫øu c√≥)
                if (Array.isArray(e.removed)) {
                    e.removed.forEach(item => {
                        const el = this.itemElems.get(item);
                        if (el) {
                            el.remove();
                            this.itemElems.delete(item);
                        }
                    });
                }

                // 2Ô∏è‚É£ Th√™m ph·∫ßn t·ª≠ m·ªõi (n·∫øu c√≥)
                if (Array.isArray(e.added)) {
                    e.added.forEach((item, i) => {
                        const elem = this._createItemElement(item);

                        // x√°c ƒë·ªãnh ph·∫ßn t·ª≠ tham chi·∫øu
                        const nextItem = this._data.items[e.index + i + 1];
                        const refElem = nextItem ? this.itemElems.get(nextItem) : null;

                        if (refElem) this.insertBefore(elem, refElem);
                        else this.appendChild(elem);

                        this.itemElems.set(item, elem);
                    });
                }
            }

            _createItemElement(itemData) {
                const C = ParamListView.CLASSES;
                const T = ParamListView.TAGS;
                // --- group ---
                if (itemData.children) {
                    const groupBlock = document.createElement("div");
                    groupBlock.className = C.groupBlock;

                    const header = document.createElement("div");
                    header.className = C.groupHeader;
                    header.textContent =
                        (itemData.expanded ? "‚ñº " : "‚ñ∂ ") + itemData.name + " (Group)";
                    groupBlock.appendChild(header);

                    const childrenContainer = document.createElement("div");
                    childrenContainer.className = C.groupChildren;
                    childrenContainer.style.display = itemData.expanded ? "block" : "none";

                    const childList = document.createElement(T.param_list);
                    childList.innerHTML = this.querySelector(T.item_template).outerHTML;
                    childList.rootView = this.rootView ?? this;
                    childList.data = itemData.children;
                    childrenContainer.appendChild(childList);
                    groupBlock.appendChild(childrenContainer);

                    // toggle expand/collapse
                    header.addEventListener("click", () => {
                        itemData.expanded = !itemData.expanded;
                        childrenContainer.style.display = itemData.expanded ? "block" : "none";
                        header.textContent =
                            (itemData.expanded ? "‚ñº " : "‚ñ∂ ") + itemData.name + " (Group)";
                        this._emitEvent("grouptoggle", { group: itemData, expanded: itemData.expanded });
                    });

                    // drag/drop
                    this._attachDragDrop(header, itemData);
                    this._attachItemEvents(header, itemData);
                    return groupBlock;
                }

                // --- item th∆∞·ªùng ---
                const template = this.querySelector(T.item_template);
                const fragment = template.content.cloneNode(true);

                this._bindFragmentToItem(fragment, itemData);

                const container = document.createElement("div");
                container.appendChild(fragment);
                const elem = container.firstElementChild;
                elem.classList.add(C.item);

                this._attachDragDrop(elem, itemData);
                this._attachItemEvents(elem, itemData);
                return elem;
            }

            _attachDragDrop(elem, itemData) {
                const root = this.rootView ?? this;
                elem.draggable = true;

                function isAbleToDrop(listView, fromNode, toNode) {
                    return listView._isAncestor(fromNode, toNode)
                }
                elem.addEventListener("dragstart", e => {
                    e.stopPropagation();
                    e.dataTransfer.effectAllowed = "move";
                    root._draggingItem = itemData;
                    elem.classList.add("dragging");
                    console.log("dragstart:", itemData.name);
                });

                elem.addEventListener("dragend", e => {
                    elem.classList.remove("dragging");
                    root._draggingItem = null;
                });

                elem.addEventListener("dragover", e => {
                    e.preventDefault();
                    const fromItem = root._draggingItem;
                    const toItem = itemData;
                    if (this._isAncestor(fromItem, toItem)) {
                        return;
                    }
                    elem.style.borderTop = "2px solid blue";
                });

                elem.addEventListener("dragleave", e => {
                    elem.style.borderTop = "";
                });

                elem.addEventListener("drop", e => {
                    e.preventDefault();
                    elem.style.borderTop = "";

                    const fromItem = root._draggingItem;
                    const toItem = itemData;
                    console.log("drop:", { toItem, fromItem });

                    if (!fromItem || fromItem === toItem) return;
                    if (this._isAncestor(fromItem, toItem)) {
                        return;
                    }
                    const fromList = fromItem.parent;
                    const toList = toItem.parent;
                    if (!fromList || !toList) return;

                    const fromIndex = fromList.items.indexOf(fromItem);
                    const toIndex = toList.items.indexOf(toItem);
                    if (fromIndex === -1 || toIndex === -1) return;

                    console.log(`drop ${fromItem.name} ‚Üí ${toItem.name}`);

                    const [moved] = fromList.splice(fromIndex, 1);
                    const adjustedIndex =
                        fromList === toList && fromIndex < toIndex ? toIndex - 1 : toIndex;

                    toList.splice(adjustedIndex, 0, moved);
                });
            }

            _bindFragmentToItem(fragment, itemData) {
                const bindings = []; // danh s√°ch li√™n k·∫øt { key, node, type, attrName? }

                // 1Ô∏è‚É£ Text nodes
                const walker = document.createTreeWalker(fragment, NodeFilter.SHOW_TEXT, null, false);
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    const matches = node.textContent.match(/{{\s*([\w]+)\s*}}/g);
                    if (matches) {
                        matches.forEach(m => {
                            const key = m.replace(/[{}]/g, "").trim();
                            if (itemData[key] !== undefined) {
                                // render ban ƒë·∫ßu
                                node.textContent = node.textContent.replace(m, itemData[key]);
                                // l∆∞u l·∫°i binding
                                bindings.push({ key, node, type: "text" });
                            }
                        });
                    }
                }

                // 2Ô∏è‚É£ Attributes
                fragment.querySelectorAll("*").forEach(el => {
                    for (let attr of el.attributes) {
                        const m = attr.value.match(/{{\s*([\w]+)\s*}}/);
                        if (m) {
                            const key = m[1];
                            if (itemData[key] !== undefined) {
                                // render ban ƒë·∫ßu
                                el.setAttribute(attr.name, itemData[key]);

                                // n·∫øu l√† input.value ‚Üí t·∫°o 2 chi·ªÅu
                                if (attr.name === "value" && el.tagName === "INPUT") {
                                    el.value = itemData[key];
                                    el.addEventListener("input", () => {
                                        itemData[key] = el.value; // view ‚Üí model
                                    });
                                }

                                // l∆∞u l·∫°i binding (ƒë·ªÉ update khi model ƒë·ªïi)
                                bindings.push({ key, node: el, type: "attr", attrName: attr.name });
                            }
                        }
                    }
                });

                // 3Ô∏è‚É£ Khi model thay ƒë·ªïi ‚Üí update view
                if (typeof itemData.registerListener === "function") {
                    itemData.registerListener(e => {
                        const { field, newValue } = e;
                        bindings.forEach(b => {
                            if (b.key === field) {
                                if (b.type === "text") {
                                    b.node.textContent = newValue; // update text node
                                } else if (b.type === "attr") {
                                    b.node.setAttribute(b.attrName, newValue);
                                    if (b.attrName === "value" && b.node.tagName === "INPUT") {
                                        b.node.value = newValue; // model ‚Üí view
                                    }
                                }
                            }
                        });
                    });
                }

                return bindings;
            }

            // ==================== EVENT BINDING ====================

            _emitEvent(type, detail) {
                // T·∫°o b·∫£n sao detail ƒë·ªÉ c√≥ th·ªÉ th√™m extraParam sau
                let eventDetail = { ...detail };

                const event = new CustomEvent(type, {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    detail: eventDetail
                });

                this.dispatchEvent(event);

                const attrName = "on" + type.toLowerCase();
                const inlineHandler = this.rootView.getAttribute(attrName);

                if (inlineHandler) {
                    const match = inlineHandler.match(/^(\w+)\((.*)\)$/);
                    if (match) {
                        const fnName = match[1];
                        const argsStr = match[2].trim();

                        if (window[fnName]) {
                            let extraParam = null;

                            if (argsStr) {
                                try {
                                    extraParam = new Function(`return [${argsStr}]`)();
                                } catch (e) {
                                    console.warn("Failed to parse inline params:", e);
                                }
                            }

                            // G·∫Øn extraParam v√†o event.detail m√† KH√îNG ghi ƒë√® event.detail
                            event.detail.extraParam = extraParam;

                            window[fnName](event);
                        }
                    } else {
                        if (window[inlineHandler]) {
                            window[inlineHandler](event);
                        }
                    }
                }
            }

            _attachItemEvents(elem, itemData) {
                elem.addEventListener("click", e => {
                    e.stopPropagation();
                    this._emitEvent("itemclick", { item: itemData, element: elem });
                });

                elem.addEventListener("contextmenu", e => {
                    e.preventDefault();
                    e.stopPropagation();
                    this._emitEvent("itemcontextmenu", {
                        item: itemData,
                        element: elem,
                        x: e.clientX,
                        y: e.clientY
                    });
                });
            }

        }

        class AutoScrollInput extends HTMLElement {
            connectedCallback() {
                // n·∫øu trong tag ch∆∞a c√≥ input th√¨ m·ªõi t·∫°o
                if (!this.querySelector("input")) {
                    const input = document.createElement("input");

                    // copy to√†n b·ªô attribute t·ª´ custom tag xu·ªëng input
                    Array.from(this.attributes).forEach(attr => {
                        input.setAttribute(attr.name, attr.value);
                    });

                    // auto scroll khi focus
                    input.addEventListener("focus", () => {
                        if (isMobile) {
                            setTimeout(() => {
                                input.scrollIntoView({ behavior: "smooth", block: "center" });
                            }, 300);
                        }
                    });
                    this.appendChild(input);
                }
            }

            // getter/setter ƒë·ªÉ d√πng nh∆∞ <input>
            get value() {
                return this.querySelector("input")?.value;
            }
            set value(val) {
                if (this.querySelector("input")) {
                    this.querySelector("input").value = val;
                }
            }
        }

        class FormattedInput extends AutoScrollInput {
            connectedCallback() {
                super.connectedCallback();
                const input = this.querySelector("input");

                const format = this.getAttribute("format") || "";

                // set gi√° tr·ªã ban ƒë·∫ßu (formatted)
                if (this.hasAttribute("value")) {
                    input.value = this.formatValue(this.getAttribute("value"), format);
                }

                // Khi focus ‚Üí hi·ªán raw value
                input.addEventListener("focus", () => {
                    const raw = this.getAttribute("value");
                    if (raw !== null) input.value = raw;
                });

                // Khi blur ‚Üí format l·∫°i
                input.addEventListener("blur", () => {
                    let val = input.value;
                    let num = parseFloat(val.replace(/[^\d.-]/g, ""));
                    if (isNaN(num)) num = 0;

                    this.setAttribute("value", num); // update attribute ƒë·ªÉ ƒë·ªìng b·ªô
                    input.value = this.formatValue(num, format);

                    // trigger s·ª± ki·ªán custom ƒë·ªÉ cha bi·∫øt c√≥ update
                    //this.dispatchEvent(new CustomEvent("valueChanged", { detail: { key: this.id, value: num } }));
                });

                input.addEventListener("blur", () => {
                    let val = input.value;
                    let num = parseFloat(val.replace(/[^\d.-]/g, ""));
                    if (isNaN(num)) num = 0;

                    this.setAttribute("value", num); // update attribute ƒë·ªÉ ƒë·ªìng b·ªô
                    input.value = this.formatValue(num, format);

                    // trigger s·ª± ki·ªán custom ƒë·ªÉ cha bi·∫øt c√≥ update
                    //this.dispatchEvent(new CustomEvent("valueChanged", { detail: { key: this.id, value: num } }));
                });
            }

            formatValue(val, format) {
                if (val == null || isNaN(val)) return val;
                switch (format) {
                    case "currency":
                        return new Intl.NumberFormat("vi-VN").format(val) + " VND";
                    case "decimal":
                        return new Intl.NumberFormat("vi-VN", { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(val);
                    case "percent":
                        return val + " %";
                    default:
                        return val;
                }
            }

            get value() { return parseFloat(this.getAttribute("value")); }
            set value(val) {
                this.setAttribute("value", val);
                const format = this.getAttribute("format") || "";
                this.querySelector("input").value = this.formatValue(val, format);
            }
        }
    </script>
    <script des="app">
        // ƒêƒÉng k√Ω custom tag <auto-scroll-input>
        customElements.define("auto-scroll-input", AutoScrollInput);
        customElements.define("formatted-input", FormattedInput);
        customElements.define(ParamListView.TAGS.param_list, ParamListView);
    </script>
    <script des="controller">

        //#region View function
        function toggleFullscreen() {
            const btn = document.getElementById("fullscreenBtn");

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // V√†o fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                }
                btn.innerText = "‚ùé Tho√°t Fullscreen";
            } else {
                // Tho√°t fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                btn.innerText = "üî≥ V√†o Fullscreen";
            }
        }

        function exportData() {
            // H·ªèi t√™n file
            let filename = prompt("Nh·∫≠p t√™n file ƒë·ªÉ l∆∞u:", "pt-data");
            if (filename === null) return; // user b·∫•m Cancel
            filename = filename.trim() || "pt-data"; // n·∫øu b·ªè tr·ªëng th√¨ l·∫•y m·∫∑c ƒë·ªãnh

            // Gom d·ªØ li·ªáu
            const data = {
                params: params,
                formulas: formulas
            };
            saveToLocal(data)
            // T·∫°o file JSON
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename.endsWith(".json") ? filename : filename + ".json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    params = data.params || {};
                    formulas = data.formulas || {};
                    renderParams();
                    renderFormulas();
                    updateFormulaResults();
                    alert("Import d·ªØ li·ªáu th√†nh c√¥ng!");
                } catch (err) {
                    alert("File kh√¥ng h·ª£p l·ªá: " + err.message);
                }
            };
            reader.readAsText(file);
        }
        //#region X·ª≠ l√Ω layout divider
        const divider = document.getElementById("divider");
        const mainContainer = document.getElementById("mainContainer");
        const paramContainer = document.getElementById("paramContainer");

        let isResizing = false;

        divider.addEventListener("mousedown", startResize);
        divider.addEventListener("touchstart", startResize, { passive: false });

        function startResize(e) {
            isResizing = true;
            document.body.classList.add("mouse-effect-no-select");
            document.addEventListener("mousemove", resize);
            document.addEventListener("mouseup", stopResize);
            document.addEventListener("touchmove", resize, { passive: false });
            document.addEventListener("touchend", stopResize);
        }

        function resize(e) {
            if (!isResizing) return;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;

            // T√≠nh t·ªça ƒë·ªô X t∆∞∆°ng ƒë·ªëi trong container
            const rect = mainContainer.getBoundingClientRect();
            const dividerWidth = divider.getBoundingClientRect().width;
            let x = clientX - rect.left;               // px t·ª´ m√©p tr√°i container
            let newWidth = ((x - dividerWidth / 2) / rect.width) * 100;     // ƒë·ªïi sang %

            // Gi·ªõi h·∫°n min‚Äìmax
            const MIN_PCT = 30, MAX_PCT = 60;
            if (newWidth < MIN_PCT) newWidth = MIN_PCT;
            if (newWidth > MAX_PCT) newWidth = MAX_PCT;

            // Set flex-basis ƒë·ªÉ ƒë·ªïi chi·ªÅu r·ªông c·ªôt tr√°i
            paramContainer.style.flexBasis = `${newWidth}%`;

            // NgƒÉn scroll khi k√©o tr√™n mobile
            if (e.cancelable) e.preventDefault();

            // Debug
            // console.log("x=", x, "rect.width=", rect.width, "newWidth%=", newWidth);
        }

        function stopResize() {
            isResizing = false;
            document.body.classList.remove("mouse-effect-no-select");
            document.removeEventListener("mousemove", resize);
            document.removeEventListener("mouseup", stopResize);
            document.removeEventListener("touchmove", resize);
            document.removeEventListener("touchend", stopResize);
        }
        //#endregion

        //#endregion

        //#region Utils
        function formatValue(val, format) {
            console.log("formatValue");

            if (val == null || isNaN(val)) return val;

            switch (format) {
                case "currency":
                    return new Intl.NumberFormat("vi-VN").format(val) + " VND";
                case "decimal":
                    return new Intl.NumberFormat("vi-VN", { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(val);
                case "percent":
                    return val + " %";
                default:
                    return val; // m·∫∑c ƒë·ªãnh: hi·ªÉn th·ªã raw
            }
        }
        //#endregion

        //#region List Context Menu
        let currentType = null;
        let currentName = null;
        const menu = document.getElementById("contextMenu");

        const MENU_ACTIONS = {
            param: [
                { icon: "‚úèÔ∏è", label: "Edit", action: (name) => editParam(name) },
                { icon: "‚ùå", label: "Delete", action: (name) => deleteParam(name) }
            ],
            formula: [
                { icon: "‚úèÔ∏è", label: "Edit", action: (name) => editFormula(name) },
                { icon: "‚ùå", label: "Delete", action: (name) => deleteFormula(name) }
            ]
        };
        function handleContextMenu(e) {
            const { item, x, y, extraParam } = e.detail;
            console.log("üü† Context menu:", item.name, x, y);
            const type = extraParam[0]
            const itemName = item.name
            // Build menu items theo type
            menu.innerHTML = MENU_ACTIONS[type]
                .map(item => `
      <div class="context-menu-item" onclick="handleContext('${item.label}', '${type}', '${itemName}')">
        ${item.icon} ${item.label}
      </div>
    `).join("");

            menu.style.display = "block";
            menu.style.left = x + "px";
            menu.style.top = y + "px";
        }

        function handleContext(label, type, itemName) {
            if (!type || !itemName) return;
            const item = MENU_ACTIONS[type].find(x => x.label === label);
            if (item) item.action(itemName);
            menu.style.display = "none";
        }

        // ·∫®n menu khi click ra ngo√†i
        document.addEventListener("click", () => menu.style.display = "none");

        //#endregion 

        //#region Param
        let params = {};
        const observableListParams = new ObservableList([]);
        const paramIndexer = new ObservableIndexer(observableListParams, "name");

        const paramsView = document.getElementById("paramsView");
        paramsView.data = observableListParams;

        let editingParamName = null;

        function editParam(name) {
            const p = params[name];
            if (!p) return;

            // Fill input
            document.getElementById("paramName").value = name;
            document.getElementById("paramValue").value = p.value;
            document.getElementById("paramGroup").value = p.group;
            document.getElementById("paramColor").value = p.color;
            document.getElementById("paramDesc").value = p.desc || "";
            document.getElementById("paramFormat").value = p.format;
            document.getElementById("addParamButton").innerHTML = "C·∫≠p nh·∫≠t";
            editingParamName = name; // ƒë√°nh d·∫•u ƒëang edit
        }

        function addParam() {
            const name = document.getElementById("paramName").value.trim();
            const value = parseFloat(document.getElementById("paramValue").value);
            const desc = document.getElementById("paramDesc").value.trim();
            const group = document.getElementById("paramGroup").value.trim();
            const color = document.getElementById("paramColor").value;
            const format = document.getElementById("paramFormat").value;

            if (!name) { alert("T√™n param kh√¥ng ƒë∆∞·ª£c r·ªóng!"); return; }
            if (isNaN(value)) { alert("Gi√° tr·ªã ph·∫£i l√† s·ªë!"); return; }

            if (paramIndexer.has(name)) {
                alert(`Param ${name} ƒë√£ t·ªìn t·∫°i!`); return;
            }
            const newItem = new ObservableListItem({
                name,
                value,
                desc,
                color,
                format
            });
            observableListParams.addToGroup(group, newItem);
            newItem.registerListener(e => {
                const { field, item, newValue, oldValue } = e;
                if (field == 'value' && newValue != oldValue) {
                    updateFormulaResults();
                }
            });

            newItem.registerBeforeValueChangedListener(e => {
                const { field, item, newValue, oldValue } = e;
                if (field == 'value') {
                    floatNewValue = parseFloat(newValue);
                    return floatNewValue;
                }
                return newValue;
            });
            document.getElementById("paramName").value = "";
            document.getElementById("paramValue").value = "";
            document.getElementById("paramDesc").value = "";
            document.getElementById("paramGroup").value = "";
            document.getElementById("paramColor").value = "#f0f0f0";
        }


        function toggleBlock(id) {
            const el = document.getElementById(id);
            const title = el.previousElementSibling; // h3
            if (el.style.display === "none") {
                el.style.display = "block";
                title.innerText = title.innerText.replace("‚ûï", "‚ûñ");
            } else {
                el.style.display = "none";
                title.innerText = title.innerText.replace("‚ûñ", "‚ûï");
            }
        }

        function deleteParam(key) {
            param = paramIndexer.get(key);
            if (param) {
                param.parent.remove(param);
            }
        }

        // Render danh s√°ch param v·ªõi input ƒë·ªÉ ch·ªânh s·ª≠a realtime
        let groupState = {}; // L∆∞u tr·∫°ng th√°i expand/collapse c·ªßa t·ª´ng group

        function renderParams() {
        }


        function updateParamFormatted(key, val) {
            console.log("updateParamFormatted");
            // lo·∫°i b·ªè k√Ω t·ª± kh√¥ng ph·∫£i s·ªë tr∆∞·ªõc
            let num = parseFloat(val.replace(/[^\d.-]/g, ""));
            if (isNaN(num)) num = 0;
            if (params[key]) {
                params[key].value = num;
                renderParams();
                updateFormulaResults();
            }
        }

        function toggleGroup(g) {
            groupState[g] = !groupState[g];
            renderParams();
        }

        //#endregion

        //#region Formula
        let formulas = {};   // key = t√™n c√¥ng th·ª©c, value = { raw, display }
        const observableListFormulas = new ObservableList([]);
        const formulaIndexer = new ObservableIndexer(observableListFormulas, "name");

        const formulasView = document.getElementById("formulasView");
        formulasView.data = observableListFormulas;
        let editingFormulaName = null;

        // Format c√¥ng th·ª©c: th√™m kho·∫£ng tr·∫Øng v√† ƒë·ªïi * th√†nh √ó
        function formatFormulaDisplay(formula) {
            return formula
                .replace(/\*/g, "√ó")              // ƒë·ªïi d·∫•u nh√¢n
                .replace(/\//g, "√∑")              // c√≥ th·ªÉ ƒë·ªïi d·∫•u chia
                .replace(/([\+\-\√ó√∑])/g, " $1 ")  // th√™m kho·∫£ng tr·∫Øng quanh to√°n t·ª≠
                .replace(/\s+/g, " ")             // g·ªôp nhi·ªÅu kho·∫£ng tr·∫Øng th√†nh 1
                .trim();
        }

        function deleteFormula(name) {
            delete formulas[name];
            renderFormulas();
            updateFormulaResults();
        }

        function editFormula(name) {
            const f = formulas[name];
            if (!f) return;

            document.getElementById("formulaName").value = name;
            document.getElementById("formulaInput").value = f.raw;
            document.getElementById("formulaDesc").value = f.desc || "";

            editingFormulaName = name;
        }

        function addFormula() {
            const name = document.getElementById("formulaName").value.trim() || `C${Object.keys(formulas).length + 1}`;
            const formula = document.getElementById("formulaInput").value.trim();
            const desc = document.getElementById("formulaDesc").value.trim();
            const group = document.getElementById("formulaGroup").value.trim();

            if (!formula) { alert("Ch∆∞a nh·∫≠p c√¥ng th·ª©c!"); return; }

            // N·∫øu ƒëang edit ‚Üí x√≥a c√¥ng th·ª©c c≈©
            if (editingFormulaName) {
                document.getElementById("addFormulaButton").innerHTML = "Th√™m c√¥ng th·ª©c";
                delete formulas[editingFormulaName];
                editingFormulaName = null;
            }

            const newItem = new ObservableListItem({
                name: name,
                raw: formula,
                desc: desc,
                display: formula,
                result: "1"
            });

            observableListFormulas.addToGroup(group, newItem);

            updateFormulaResults();

            document.getElementById("formulaName").value = "";
            document.getElementById("formulaInput").value = "";
            document.getElementById("formulaDesc").value = "";
            document.getElementById("formulaGroup").value = "";
        }

        // Render danh s√°ch c√¥ng th·ª©c
        function renderFormulas() {
            let html = "<h4>Danh s√°ch c√¥ng th·ª©c:</h4>";
            for (let [name, f] of Object.entries(formulas)) {
                html += `
      <div class="formula-item list-item" 
            oncontextmenu="openContextMenu(event, 'formula', '${name}')"
            style="--list-item-bg:${'#dddddd'};">
        <div>
          <span><b>${name}</b>: <span id="formulaDisplay_${name}">${f.display}</span></span>
          <span id="formulaResult_${name}" class="formula-result"></span>
          <div style="font-size:12px; color:#666;">${f.desc || ""}</div>
        </div>
      </div>`;
            }
            document.getElementById("formulas").innerHTML = html;
        }

        // T√≠nh to√°n l·∫°i t·∫•t c·∫£ c√¥ng th·ª©c
        function updateFormulaResults() {
            let scope = {};
            // 1) Map params -> scope (l·∫•y field value n·∫øu l√† object)
            for (let [k, v] of paramIndexer.entries()) {
                scope[k] = (v && typeof v === "object" && "value" in v) ? v.value : v;
            }

            // 2) Ti√™m alias c√°c h√†m/const to√°n h·ªçc ph·ªï bi·∫øn v√†o scope
            const MATH_ALIASES = {
                ceil: Math.ceil,
                floor: Math.floor,
                round: Math.round,
                min: Math.min,
                max: Math.max,
                pow: Math.pow,
                abs: Math.abs,
                sqrt: Math.sqrt,
                log: Math.log,
                exp: Math.exp,
                sin: Math.sin,
                cos: Math.cos,
                tan: Math.tan,
                asin: Math.asin,
                acos: Math.acos,
                atan: Math.atan,
                atan2: Math.atan2,
                trunc: Math.trunc,
                random: Math.random,
                PI: Math.PI,
                E: Math.E
            };
            Object.assign(scope, MATH_ALIASES);

            // T·∫≠p t√™n ‚Äúƒë∆∞·ª£c ph√©p‚Äù ƒë·ªÉ kh√¥ng b·ªã highlight thi·∫øu
            const ALLOWED_NAMES = new Set([...Object.keys(scope), "Math"]);

            for (let [name, f] of formulaIndexer.entries()) {
                try {
                    let keys = Object.keys(scope);
                    let values = Object.values(scope);

                    // Evaluate c√¥ng th·ª©c
                    let func = new Function(...keys, `return ${f.raw};`);
                    let result = func(...values);

                    // L∆∞u k·∫øt qu·∫£ v√†o scope ƒë·ªÉ c√°c c√¥ng th·ª©c sau c√≥ th·ªÉ d√πng ti·∫øp
                    scope[name] = result;
                    formulaIndexer.get(name)['result'] = result;
                    // Render UI

                } catch (e) {
                    // B·∫Øt t√™n bi·∫øn/h√†m trong raw
                    const tokens = f.raw.match(/[a-zA-Z_]\w*/g) || [];
                    // L·ªçc ra nh·ªØng t√™n ch∆∞a c√≥ trong scope v√† kh√¥ng thu·ªôc allowed (Math funcs/const)
                    const missing = tokens.filter(t => !ALLOWED_NAMES.has(t));

                    if (missing.length > 0) {
                        // highlight ƒë·ªè c√°c bi·∫øn thi·∫øu trong display
                        const highlighted = f.display.replace(
                            new RegExp("\\b(" + missing.join("|") + ")\\b", "g"),
                            '<span style="color:red;font-weight:bold;">$1</span>'
                        );
                        document.getElementById("formulaDisplay_" + name).innerHTML = highlighted;
                        document.getElementById("formulaResult_" + name).innerText =
                            " (Thi·∫øu: " + missing.join(", ") + ")";
                    } else if (/Unexpected/.test(e.message)) {
                        document.getElementById("formulaResult_" + name).innerText = " (L·ªói c√∫ ph√°p)";
                    } else {
                        document.getElementById("formulaResult_" + name).innerText = " (L·ªói: " + e.message + ")";
                    }
                }
            }
        }

        //#endregion

        // L∆∞u local m·ªói khi c√≥ thay ƒë·ªïi
        function clearWorkspace() {
            if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën xo√° to√†n b·ªô Param v√† Formula hi·ªán t·∫°i kh√¥ng?")) return;

            params = {};
            formulas = {};
            renderParams();
            renderFormulas();
            updateFormulaResults();
            saveToLocal({ params, formulas }); // clear c·∫£ localStorage lu√¥n
        }

        function saveToLocal(data) {
            localStorage.setItem("pt-latest-data", JSON.stringify(data));
        }

        // Load khi m·ªü page
        function loadFromLocal() {
            const raw = localStorage.getItem("pt-latest-data");
            if (!raw) return;
            try {
                const data = JSON.parse(raw);
                params = data.params || {};
                formulas = data.formulas || {};
                renderParams();
                //renderFormulas();
                updateFormulaResults();
            } catch (e) {
                console.error("Kh√¥ng load ƒë∆∞·ª£c d·ªØ li·ªáu local:", e);
            }
        }

        // G·ªçi khi page kh·ªüi ƒë·ªông
        window.addEventListener("DOMContentLoaded", loadFromLocal);


        // Ch√®n saveToLocal() v√†o cu·ªëi addParam, addFormula, deleteParam, deleteFormula

    </script>
    <script>
        function handleItemClick(e) {
            const { item } = e.detail;
            alert("üü¢ Clicked: " + item.name);
        }

        function handleGroupToggle(e) {
            const { group, expanded } = e.detail;
            console.log(`üìÇ Group ${group.name} is now ${expanded ? "expanded" : "collapsed"}`);
        }
    </script>
</body>

</html>